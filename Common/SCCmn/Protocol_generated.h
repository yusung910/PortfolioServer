// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

struct HostConnect;
struct HostConnectBuilder;
struct HostConnectT;

struct HostClose;
struct HostCloseBuilder;
struct HostCloseT;

struct HostConnectFailed;
struct HostConnectFailedBuilder;
struct HostConnectFailedT;

struct HostHello;
struct HostHelloBuilder;
struct HostHelloT;

struct SCIntegrationErrorNotification;
struct SCIntegrationErrorNotificationBuilder;
struct SCIntegrationErrorNotificationT;

struct CSAuthReq;
struct CSAuthReqBuilder;
struct CSAuthReqT;

struct SCAuthRes;
struct SCAuthResBuilder;
struct SCAuthResT;

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
enum EPacketProtocol {
  None = 0,
  Host_Connect = 1,
  Host_Close = 2,
  Host_ConnectFailed = 3,
  Host_Hello = 12,
  SC_IntegrationErrorNotification = 10000,
  CS_AuthReq = 10001,
  SC_AuthRes = 10002,
  PacketMax = 10003
};

inline const EPacketProtocol (&EnumValuesEPacketProtocol())[9] {
  static const EPacketProtocol values[] = {
    None,
    Host_Connect,
    Host_Close,
    Host_ConnectFailed,
    Host_Hello,
    SC_IntegrationErrorNotification,
    CS_AuthReq,
    SC_AuthRes,
    PacketMax
  };
  return values;
}

inline const char *EnumNameEPacketProtocol(EPacketProtocol e) {
  switch (e) {
    case None: return "None";
    case Host_Connect: return "Host_Connect";
    case Host_Close: return "Host_Close";
    case Host_ConnectFailed: return "Host_ConnectFailed";
    case Host_Hello: return "Host_Hello";
    case SC_IntegrationErrorNotification: return "SC_IntegrationErrorNotification";
    case CS_AuthReq: return "CS_AuthReq";
    case SC_AuthRes: return "SC_AuthRes";
    case PacketMax: return "PacketMax";
    default: return "";
  }
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
enum EErrorMsg {
  EF_NONE = 0,
  EF_HOST_IP_IS_NOT_ALLOWED = 11,
  EF_DUPLICATE_CONNECTION_NET_ALLOWED = 12,
  EF_LOGIN_PF_ERROR = 101
};

inline const EErrorMsg (&EnumValuesEErrorMsg())[4] {
  static const EErrorMsg values[] = {
    EF_NONE,
    EF_HOST_IP_IS_NOT_ALLOWED,
    EF_DUPLICATE_CONNECTION_NET_ALLOWED,
    EF_LOGIN_PF_ERROR
  };
  return values;
}

inline const char *EnumNameEErrorMsg(EErrorMsg e) {
  switch (e) {
    case EF_NONE: return "EF_NONE";
    case EF_HOST_IP_IS_NOT_ALLOWED: return "EF_HOST_IP_IS_NOT_ALLOWED";
    case EF_DUPLICATE_CONNECTION_NET_ALLOWED: return "EF_DUPLICATE_CONNECTION_NET_ALLOWED";
    case EF_LOGIN_PF_ERROR: return "EF_LOGIN_PF_ERROR";
    default: return "";
  }
}

struct HostConnectT : public flatbuffers::NativeTable {
  typedef HostConnect TableType;
  std::string peerip;
  int32_t peerport;
  int32_t servertype;
  int32_t serverid;
  EPacketProtocol messageid;
  HostConnectT()
      : peerport(0),
        servertype(0),
        serverid(0),
        messageid(Host_Connect) {
  }
};

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
struct HostConnect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostConnectT NativeTableType;
  typedef HostConnectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEERIP = 4,
    VT_PEERPORT = 6,
    VT_SERVERTYPE = 8,
    VT_SERVERID = 10,
    VT_MESSAGEID = 12
  };
  const flatbuffers::String *peerip() const {
    return GetPointer<const flatbuffers::String *>(VT_PEERIP);
  }
  int32_t peerport() const {
    return GetField<int32_t>(VT_PEERPORT, 0);
  }
  int32_t servertype() const {
    return GetField<int32_t>(VT_SERVERTYPE, 0);
  }
  int32_t serverid() const {
    return GetField<int32_t>(VT_SERVERID, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PEERIP) &&
           verifier.VerifyString(peerip()) &&
           VerifyField<int32_t>(verifier, VT_PEERPORT) &&
           VerifyField<int32_t>(verifier, VT_SERVERTYPE) &&
           VerifyField<int32_t>(verifier, VT_SERVERID) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  HostConnectT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostConnectT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostConnect> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HostConnectBuilder {
  typedef HostConnect Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peerip(flatbuffers::Offset<flatbuffers::String> peerip) {
    fbb_.AddOffset(HostConnect::VT_PEERIP, peerip);
  }
  void add_peerport(int32_t peerport) {
    fbb_.AddElement<int32_t>(HostConnect::VT_PEERPORT, peerport, 0);
  }
  void add_servertype(int32_t servertype) {
    fbb_.AddElement<int32_t>(HostConnect::VT_SERVERTYPE, servertype, 0);
  }
  void add_serverid(int32_t serverid) {
    fbb_.AddElement<int32_t>(HostConnect::VT_SERVERID, serverid, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(HostConnect::VT_MESSAGEID, static_cast<int32_t>(messageid), 1);
  }
  explicit HostConnectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HostConnectBuilder &operator=(const HostConnectBuilder &);
  flatbuffers::Offset<HostConnect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostConnect>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostConnect> CreateHostConnect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> peerip = 0,
    int32_t peerport = 0,
    int32_t servertype = 0,
    int32_t serverid = 0,
    EPacketProtocol messageid = Host_Connect) {
  HostConnectBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_serverid(serverid);
  builder_.add_servertype(servertype);
  builder_.add_peerport(peerport);
  builder_.add_peerip(peerip);
  return builder_.Finish();
}

inline flatbuffers::Offset<HostConnect> CreateHostConnectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *peerip = nullptr,
    int32_t peerport = 0,
    int32_t servertype = 0,
    int32_t serverid = 0,
    EPacketProtocol messageid = Host_Connect) {
  auto peerip__ = peerip ? _fbb.CreateString(peerip) : 0;
  return CreateHostConnect(
      _fbb,
      peerip__,
      peerport,
      servertype,
      serverid,
      messageid);
}

flatbuffers::Offset<HostConnect> CreateHostConnect(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HostCloseT : public flatbuffers::NativeTable {
  typedef HostClose TableType;
  EPacketProtocol messageid;
  HostCloseT()
      : messageid(Host_Close) {
  }
};

struct HostClose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostCloseT NativeTableType;
  typedef HostCloseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGEID = 4
  };
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 2));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  HostCloseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostCloseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostClose> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostCloseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HostCloseBuilder {
  typedef HostClose Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(HostClose::VT_MESSAGEID, static_cast<int32_t>(messageid), 2);
  }
  explicit HostCloseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HostCloseBuilder &operator=(const HostCloseBuilder &);
  flatbuffers::Offset<HostClose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostClose>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostClose> CreateHostClose(
    flatbuffers::FlatBufferBuilder &_fbb,
    EPacketProtocol messageid = Host_Close) {
  HostCloseBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  return builder_.Finish();
}

flatbuffers::Offset<HostClose> CreateHostClose(flatbuffers::FlatBufferBuilder &_fbb, const HostCloseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HostConnectFailedT : public flatbuffers::NativeTable {
  typedef HostConnectFailed TableType;
  EPacketProtocol messageid;
  HostConnectFailedT()
      : messageid(Host_ConnectFailed) {
  }
};

struct HostConnectFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostConnectFailedT NativeTableType;
  typedef HostConnectFailedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGEID = 4
  };
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 3));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  HostConnectFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostConnectFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostConnectFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HostConnectFailedBuilder {
  typedef HostConnectFailed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(HostConnectFailed::VT_MESSAGEID, static_cast<int32_t>(messageid), 3);
  }
  explicit HostConnectFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HostConnectFailedBuilder &operator=(const HostConnectFailedBuilder &);
  flatbuffers::Offset<HostConnectFailed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostConnectFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostConnectFailed> CreateHostConnectFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    EPacketProtocol messageid = Host_ConnectFailed) {
  HostConnectFailedBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  return builder_.Finish();
}

flatbuffers::Offset<HostConnectFailed> CreateHostConnectFailed(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HostHelloT : public flatbuffers::NativeTable {
  typedef HostHello TableType;
  int32_t servertype;
  int32_t serverid;
  std::string name;
  int32_t buildtype;
  EPacketProtocol messageid;
  HostHelloT()
      : servertype(0),
        serverid(0),
        buildtype(0),
        messageid(Host_Hello) {
  }
};

struct HostHello FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostHelloT NativeTableType;
  typedef HostHelloBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVERTYPE = 4,
    VT_SERVERID = 6,
    VT_NAME = 8,
    VT_BUILDTYPE = 10,
    VT_MESSAGEID = 12
  };
  int32_t servertype() const {
    return GetField<int32_t>(VT_SERVERTYPE, 0);
  }
  int32_t serverid() const {
    return GetField<int32_t>(VT_SERVERID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t buildtype() const {
    return GetField<int32_t>(VT_BUILDTYPE, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 12));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SERVERTYPE) &&
           VerifyField<int32_t>(verifier, VT_SERVERID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_BUILDTYPE) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  HostHelloT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostHelloT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostHello> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostHelloT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HostHelloBuilder {
  typedef HostHello Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_servertype(int32_t servertype) {
    fbb_.AddElement<int32_t>(HostHello::VT_SERVERTYPE, servertype, 0);
  }
  void add_serverid(int32_t serverid) {
    fbb_.AddElement<int32_t>(HostHello::VT_SERVERID, serverid, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(HostHello::VT_NAME, name);
  }
  void add_buildtype(int32_t buildtype) {
    fbb_.AddElement<int32_t>(HostHello::VT_BUILDTYPE, buildtype, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(HostHello::VT_MESSAGEID, static_cast<int32_t>(messageid), 12);
  }
  explicit HostHelloBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HostHelloBuilder &operator=(const HostHelloBuilder &);
  flatbuffers::Offset<HostHello> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostHello>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostHello> CreateHostHello(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t servertype = 0,
    int32_t serverid = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t buildtype = 0,
    EPacketProtocol messageid = Host_Hello) {
  HostHelloBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_buildtype(buildtype);
  builder_.add_name(name);
  builder_.add_serverid(serverid);
  builder_.add_servertype(servertype);
  return builder_.Finish();
}

inline flatbuffers::Offset<HostHello> CreateHostHelloDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t servertype = 0,
    int32_t serverid = 0,
    const char *name = nullptr,
    int32_t buildtype = 0,
    EPacketProtocol messageid = Host_Hello) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateHostHello(
      _fbb,
      servertype,
      serverid,
      name__,
      buildtype,
      messageid);
}

flatbuffers::Offset<HostHello> CreateHostHello(flatbuffers::FlatBufferBuilder &_fbb, const HostHelloT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SCIntegrationErrorNotificationT : public flatbuffers::NativeTable {
  typedef SCIntegrationErrorNotification TableType;
  int32_t SrcMsgID;
  int32_t Error;
  EPacketProtocol messageid;
  SCIntegrationErrorNotificationT()
      : SrcMsgID(0),
        Error(0),
        messageid(SC_IntegrationErrorNotification) {
  }
};

struct SCIntegrationErrorNotification FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SCIntegrationErrorNotificationT NativeTableType;
  typedef SCIntegrationErrorNotificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRCMSGID = 4,
    VT_ERROR = 6,
    VT_MESSAGEID = 8
  };
  int32_t SrcMsgID() const {
    return GetField<int32_t>(VT_SRCMSGID, 0);
  }
  int32_t Error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 10000));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRCMSGID) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  SCIntegrationErrorNotificationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SCIntegrationErrorNotificationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SCIntegrationErrorNotification> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SCIntegrationErrorNotificationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SCIntegrationErrorNotificationBuilder {
  typedef SCIntegrationErrorNotification Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SrcMsgID(int32_t SrcMsgID) {
    fbb_.AddElement<int32_t>(SCIntegrationErrorNotification::VT_SRCMSGID, SrcMsgID, 0);
  }
  void add_Error(int32_t Error) {
    fbb_.AddElement<int32_t>(SCIntegrationErrorNotification::VT_ERROR, Error, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(SCIntegrationErrorNotification::VT_MESSAGEID, static_cast<int32_t>(messageid), 10000);
  }
  explicit SCIntegrationErrorNotificationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SCIntegrationErrorNotificationBuilder &operator=(const SCIntegrationErrorNotificationBuilder &);
  flatbuffers::Offset<SCIntegrationErrorNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SCIntegrationErrorNotification>(end);
    return o;
  }
};

inline flatbuffers::Offset<SCIntegrationErrorNotification> CreateSCIntegrationErrorNotification(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t SrcMsgID = 0,
    int32_t Error = 0,
    EPacketProtocol messageid = SC_IntegrationErrorNotification) {
  SCIntegrationErrorNotificationBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_Error(Error);
  builder_.add_SrcMsgID(SrcMsgID);
  return builder_.Finish();
}

flatbuffers::Offset<SCIntegrationErrorNotification> CreateSCIntegrationErrorNotification(flatbuffers::FlatBufferBuilder &_fbb, const SCIntegrationErrorNotificationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CSAuthReqT : public flatbuffers::NativeTable {
  typedef CSAuthReq TableType;
  std::string accountid;
  std::string accountpw;
  int32_t hostid;
  EPacketProtocol messageid;
  CSAuthReqT()
      : hostid(0),
        messageid(CS_AuthReq) {
  }
};

struct CSAuthReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CSAuthReqT NativeTableType;
  typedef CSAuthReqBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNTID = 4,
    VT_ACCOUNTPW = 6,
    VT_HOSTID = 8,
    VT_MESSAGEID = 10
  };
  const flatbuffers::String *accountid() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNTID);
  }
  const flatbuffers::String *accountpw() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNTPW);
  }
  int32_t hostid() const {
    return GetField<int32_t>(VT_HOSTID, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 10001));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACCOUNTID) &&
           verifier.VerifyString(accountid()) &&
           VerifyOffset(verifier, VT_ACCOUNTPW) &&
           verifier.VerifyString(accountpw()) &&
           VerifyField<int32_t>(verifier, VT_HOSTID) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  CSAuthReqT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CSAuthReqT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CSAuthReq> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CSAuthReqT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CSAuthReqBuilder {
  typedef CSAuthReq Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accountid(flatbuffers::Offset<flatbuffers::String> accountid) {
    fbb_.AddOffset(CSAuthReq::VT_ACCOUNTID, accountid);
  }
  void add_accountpw(flatbuffers::Offset<flatbuffers::String> accountpw) {
    fbb_.AddOffset(CSAuthReq::VT_ACCOUNTPW, accountpw);
  }
  void add_hostid(int32_t hostid) {
    fbb_.AddElement<int32_t>(CSAuthReq::VT_HOSTID, hostid, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(CSAuthReq::VT_MESSAGEID, static_cast<int32_t>(messageid), 10001);
  }
  explicit CSAuthReqBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CSAuthReqBuilder &operator=(const CSAuthReqBuilder &);
  flatbuffers::Offset<CSAuthReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CSAuthReq>(end);
    return o;
  }
};

inline flatbuffers::Offset<CSAuthReq> CreateCSAuthReq(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> accountid = 0,
    flatbuffers::Offset<flatbuffers::String> accountpw = 0,
    int32_t hostid = 0,
    EPacketProtocol messageid = CS_AuthReq) {
  CSAuthReqBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_hostid(hostid);
  builder_.add_accountpw(accountpw);
  builder_.add_accountid(accountid);
  return builder_.Finish();
}

inline flatbuffers::Offset<CSAuthReq> CreateCSAuthReqDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *accountid = nullptr,
    const char *accountpw = nullptr,
    int32_t hostid = 0,
    EPacketProtocol messageid = CS_AuthReq) {
  auto accountid__ = accountid ? _fbb.CreateString(accountid) : 0;
  auto accountpw__ = accountpw ? _fbb.CreateString(accountpw) : 0;
  return CreateCSAuthReq(
      _fbb,
      accountid__,
      accountpw__,
      hostid,
      messageid);
}

flatbuffers::Offset<CSAuthReq> CreateCSAuthReq(flatbuffers::FlatBufferBuilder &_fbb, const CSAuthReqT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SCAuthResT : public flatbuffers::NativeTable {
  typedef SCAuthRes TableType;
  std::string accountid;
  std::string accountpw;
  EPacketProtocol messageid;
  SCAuthResT()
      : messageid(SC_AuthRes) {
  }
};

struct SCAuthRes FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SCAuthResT NativeTableType;
  typedef SCAuthResBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNTID = 4,
    VT_ACCOUNTPW = 6,
    VT_MESSAGEID = 8
  };
  const flatbuffers::String *accountid() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNTID);
  }
  const flatbuffers::String *accountpw() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNTPW);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 10002));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACCOUNTID) &&
           verifier.VerifyString(accountid()) &&
           VerifyOffset(verifier, VT_ACCOUNTPW) &&
           verifier.VerifyString(accountpw()) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  SCAuthResT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SCAuthResT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SCAuthRes> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SCAuthResT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SCAuthResBuilder {
  typedef SCAuthRes Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accountid(flatbuffers::Offset<flatbuffers::String> accountid) {
    fbb_.AddOffset(SCAuthRes::VT_ACCOUNTID, accountid);
  }
  void add_accountpw(flatbuffers::Offset<flatbuffers::String> accountpw) {
    fbb_.AddOffset(SCAuthRes::VT_ACCOUNTPW, accountpw);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(SCAuthRes::VT_MESSAGEID, static_cast<int32_t>(messageid), 10002);
  }
  explicit SCAuthResBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SCAuthResBuilder &operator=(const SCAuthResBuilder &);
  flatbuffers::Offset<SCAuthRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SCAuthRes>(end);
    return o;
  }
};

inline flatbuffers::Offset<SCAuthRes> CreateSCAuthRes(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> accountid = 0,
    flatbuffers::Offset<flatbuffers::String> accountpw = 0,
    EPacketProtocol messageid = SC_AuthRes) {
  SCAuthResBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_accountpw(accountpw);
  builder_.add_accountid(accountid);
  return builder_.Finish();
}

inline flatbuffers::Offset<SCAuthRes> CreateSCAuthResDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *accountid = nullptr,
    const char *accountpw = nullptr,
    EPacketProtocol messageid = SC_AuthRes) {
  auto accountid__ = accountid ? _fbb.CreateString(accountid) : 0;
  auto accountpw__ = accountpw ? _fbb.CreateString(accountpw) : 0;
  return CreateSCAuthRes(
      _fbb,
      accountid__,
      accountpw__,
      messageid);
}

flatbuffers::Offset<SCAuthRes> CreateSCAuthRes(flatbuffers::FlatBufferBuilder &_fbb, const SCAuthResT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline HostConnectT *HostConnect::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<HostConnectT> _o = std::unique_ptr<HostConnectT>(new HostConnectT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostConnect::UnPackTo(HostConnectT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = peerip(); if (_e) _o->peerip = _e->str(); }
  { auto _e = peerport(); _o->peerport = _e; }
  { auto _e = servertype(); _o->servertype = _e; }
  { auto _e = serverid(); _o->serverid = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<HostConnect> HostConnect::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostConnect(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostConnect> CreateHostConnect(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostConnectT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _peerip = _o->peerip.empty() ? 0 : _fbb.CreateString(_o->peerip);
  auto _peerport = _o->peerport;
  auto _servertype = _o->servertype;
  auto _serverid = _o->serverid;
  auto _messageid = _o->messageid;
  return CreateHostConnect(
      _fbb,
      _peerip,
      _peerport,
      _servertype,
      _serverid,
      _messageid);
}

inline HostCloseT *HostClose::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<HostCloseT> _o = std::unique_ptr<HostCloseT>(new HostCloseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostClose::UnPackTo(HostCloseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<HostClose> HostClose::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostCloseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostClose(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostClose> CreateHostClose(flatbuffers::FlatBufferBuilder &_fbb, const HostCloseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostCloseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _messageid = _o->messageid;
  return CreateHostClose(
      _fbb,
      _messageid);
}

inline HostConnectFailedT *HostConnectFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<HostConnectFailedT> _o = std::unique_ptr<HostConnectFailedT>(new HostConnectFailedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostConnectFailed::UnPackTo(HostConnectFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<HostConnectFailed> HostConnectFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostConnectFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostConnectFailed> CreateHostConnectFailed(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostConnectFailedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _messageid = _o->messageid;
  return CreateHostConnectFailed(
      _fbb,
      _messageid);
}

inline HostHelloT *HostHello::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<HostHelloT> _o = std::unique_ptr<HostHelloT>(new HostHelloT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostHello::UnPackTo(HostHelloT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = servertype(); _o->servertype = _e; }
  { auto _e = serverid(); _o->serverid = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = buildtype(); _o->buildtype = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<HostHello> HostHello::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostHelloT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostHello(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostHello> CreateHostHello(flatbuffers::FlatBufferBuilder &_fbb, const HostHelloT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostHelloT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _servertype = _o->servertype;
  auto _serverid = _o->serverid;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _buildtype = _o->buildtype;
  auto _messageid = _o->messageid;
  return CreateHostHello(
      _fbb,
      _servertype,
      _serverid,
      _name,
      _buildtype,
      _messageid);
}

inline SCIntegrationErrorNotificationT *SCIntegrationErrorNotification::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SCIntegrationErrorNotificationT> _o = std::unique_ptr<SCIntegrationErrorNotificationT>(new SCIntegrationErrorNotificationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SCIntegrationErrorNotification::UnPackTo(SCIntegrationErrorNotificationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = SrcMsgID(); _o->SrcMsgID = _e; }
  { auto _e = Error(); _o->Error = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<SCIntegrationErrorNotification> SCIntegrationErrorNotification::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SCIntegrationErrorNotificationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSCIntegrationErrorNotification(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SCIntegrationErrorNotification> CreateSCIntegrationErrorNotification(flatbuffers::FlatBufferBuilder &_fbb, const SCIntegrationErrorNotificationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SCIntegrationErrorNotificationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _SrcMsgID = _o->SrcMsgID;
  auto _Error = _o->Error;
  auto _messageid = _o->messageid;
  return CreateSCIntegrationErrorNotification(
      _fbb,
      _SrcMsgID,
      _Error,
      _messageid);
}

inline CSAuthReqT *CSAuthReq::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<CSAuthReqT> _o = std::unique_ptr<CSAuthReqT>(new CSAuthReqT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CSAuthReq::UnPackTo(CSAuthReqT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = accountid(); if (_e) _o->accountid = _e->str(); }
  { auto _e = accountpw(); if (_e) _o->accountpw = _e->str(); }
  { auto _e = hostid(); _o->hostid = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<CSAuthReq> CSAuthReq::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CSAuthReqT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCSAuthReq(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CSAuthReq> CreateCSAuthReq(flatbuffers::FlatBufferBuilder &_fbb, const CSAuthReqT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CSAuthReqT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _accountid = _o->accountid.empty() ? 0 : _fbb.CreateString(_o->accountid);
  auto _accountpw = _o->accountpw.empty() ? 0 : _fbb.CreateString(_o->accountpw);
  auto _hostid = _o->hostid;
  auto _messageid = _o->messageid;
  return CreateCSAuthReq(
      _fbb,
      _accountid,
      _accountpw,
      _hostid,
      _messageid);
}

inline SCAuthResT *SCAuthRes::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SCAuthResT> _o = std::unique_ptr<SCAuthResT>(new SCAuthResT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SCAuthRes::UnPackTo(SCAuthResT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = accountid(); if (_e) _o->accountid = _e->str(); }
  { auto _e = accountpw(); if (_e) _o->accountpw = _e->str(); }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<SCAuthRes> SCAuthRes::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SCAuthResT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSCAuthRes(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SCAuthRes> CreateSCAuthRes(flatbuffers::FlatBufferBuilder &_fbb, const SCAuthResT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SCAuthResT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _accountid = _o->accountid.empty() ? 0 : _fbb.CreateString(_o->accountid);
  auto _accountpw = _o->accountpw.empty() ? 0 : _fbb.CreateString(_o->accountpw);
  auto _messageid = _o->messageid;
  return CreateSCAuthRes(
      _fbb,
      _accountid,
      _accountpw,
      _messageid);
}

#endif  // FLATBUFFERS_GENERATED_PROTOCOL_H_
