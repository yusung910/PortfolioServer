// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

struct OServerInfo;
struct OServerInfoBuilder;
struct OServerInfoT;

struct HostConnect;
struct HostConnectBuilder;
struct HostConnectT;

struct HostClose;
struct HostCloseBuilder;
struct HostCloseT;

struct HostConnectFailed;
struct HostConnectFailedBuilder;
struct HostConnectFailedT;

struct HostHello;
struct HostHelloBuilder;
struct HostHelloT;

struct CLAuthReq;
struct CLAuthReqBuilder;
struct CLAuthReqT;

struct LCAuthRes;
struct LCAuthResBuilder;
struct LCAuthResT;

struct CSEnterGameReq;
struct CSEnterGameReqBuilder;
struct CSEnterGameReqT;

struct SCEnterGameAck;
struct SCEnterGameAckBuilder;
struct SCEnterGameAckT;

struct SCIntegrationErrorNotification;
struct SCIntegrationErrorNotificationBuilder;
struct SCIntegrationErrorNotificationT;

enum EPacketProtocol {
  None = 0,
  Host_Connect = 1,
  Host_Close = 2,
  Host_ConnectFailed = 3,
  Host_Hello = 12,
  SC_IntegrationErrorNotification = 10000,
  CL_AuthReq = 10001,
  LUDB_AuthReq = 10002,
  UDBL_AuthRes = 10003,
  LC_AuthRes = 10004,
  CS_EnterGameReq = 10005,
  SC_EnterGameAck = 10006,
  PacketMax = 10007
};

inline const EPacketProtocol (&EnumValuesEPacketProtocol())[13] {
  static const EPacketProtocol values[] = {
    None,
    Host_Connect,
    Host_Close,
    Host_ConnectFailed,
    Host_Hello,
    SC_IntegrationErrorNotification,
    CL_AuthReq,
    LUDB_AuthReq,
    UDBL_AuthRes,
    LC_AuthRes,
    CS_EnterGameReq,
    SC_EnterGameAck,
    PacketMax
  };
  return values;
}

inline const char *EnumNameEPacketProtocol(EPacketProtocol e) {
  switch (e) {
    case None: return "None";
    case Host_Connect: return "Host_Connect";
    case Host_Close: return "Host_Close";
    case Host_ConnectFailed: return "Host_ConnectFailed";
    case Host_Hello: return "Host_Hello";
    case SC_IntegrationErrorNotification: return "SC_IntegrationErrorNotification";
    case CL_AuthReq: return "CL_AuthReq";
    case LUDB_AuthReq: return "LUDB_AuthReq";
    case UDBL_AuthRes: return "UDBL_AuthRes";
    case LC_AuthRes: return "LC_AuthRes";
    case CS_EnterGameReq: return "CS_EnterGameReq";
    case SC_EnterGameAck: return "SC_EnterGameAck";
    case PacketMax: return "PacketMax";
    default: return "";
  }
}

enum EErrorMsg {
  EF_NONE = 0,
  EF_HOST_IP_IS_NOT_ALLOWED = 11,
  EF_DUPLICATE_CONNECTION_NET_ALLOWED = 12,
  EF_LOGIN_PF_ERROR = 101,
  EF_KICK = 10201,
  EF_KICK_MAINTENANCE = 10202,
  EF_KICK_DUPLICATE_LOGIN = 10211
};

inline const EErrorMsg (&EnumValuesEErrorMsg())[7] {
  static const EErrorMsg values[] = {
    EF_NONE,
    EF_HOST_IP_IS_NOT_ALLOWED,
    EF_DUPLICATE_CONNECTION_NET_ALLOWED,
    EF_LOGIN_PF_ERROR,
    EF_KICK,
    EF_KICK_MAINTENANCE,
    EF_KICK_DUPLICATE_LOGIN
  };
  return values;
}

inline const char *EnumNameEErrorMsg(EErrorMsg e) {
  switch (e) {
    case EF_NONE: return "EF_NONE";
    case EF_HOST_IP_IS_NOT_ALLOWED: return "EF_HOST_IP_IS_NOT_ALLOWED";
    case EF_DUPLICATE_CONNECTION_NET_ALLOWED: return "EF_DUPLICATE_CONNECTION_NET_ALLOWED";
    case EF_LOGIN_PF_ERROR: return "EF_LOGIN_PF_ERROR";
    case EF_KICK: return "EF_KICK";
    case EF_KICK_MAINTENANCE: return "EF_KICK_MAINTENANCE";
    case EF_KICK_DUPLICATE_LOGIN: return "EF_KICK_DUPLICATE_LOGIN";
    default: return "";
  }
}

struct OServerInfoT : public flatbuffers::NativeTable {
  typedef OServerInfo TableType;
  int32_t ServerID;
  int32_t ServerStatus;
  std::string Address;
  int32_t Port;
  bool HasCharacter;
  int32_t State;
  OServerInfoT()
      : ServerID(0),
        ServerStatus(0),
        Port(0),
        HasCharacter(false),
        State(0) {
  }
};

struct OServerInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OServerInfoT NativeTableType;
  typedef OServerInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVERID = 4,
    VT_SERVERSTATUS = 6,
    VT_ADDRESS = 8,
    VT_PORT = 10,
    VT_HASCHARACTER = 12,
    VT_STATE = 14
  };
  int32_t ServerID() const {
    return GetField<int32_t>(VT_SERVERID, 0);
  }
  int32_t ServerStatus() const {
    return GetField<int32_t>(VT_SERVERSTATUS, 0);
  }
  const flatbuffers::String *Address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  int32_t Port() const {
    return GetField<int32_t>(VT_PORT, 0);
  }
  bool HasCharacter() const {
    return GetField<uint8_t>(VT_HASCHARACTER, 0) != 0;
  }
  int32_t State() const {
    return GetField<int32_t>(VT_STATE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SERVERID) &&
           VerifyField<int32_t>(verifier, VT_SERVERSTATUS) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.VerifyString(Address()) &&
           VerifyField<int32_t>(verifier, VT_PORT) &&
           VerifyField<uint8_t>(verifier, VT_HASCHARACTER) &&
           VerifyField<int32_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
  OServerInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OServerInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OServerInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OServerInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OServerInfoBuilder {
  typedef OServerInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ServerID(int32_t ServerID) {
    fbb_.AddElement<int32_t>(OServerInfo::VT_SERVERID, ServerID, 0);
  }
  void add_ServerStatus(int32_t ServerStatus) {
    fbb_.AddElement<int32_t>(OServerInfo::VT_SERVERSTATUS, ServerStatus, 0);
  }
  void add_Address(flatbuffers::Offset<flatbuffers::String> Address) {
    fbb_.AddOffset(OServerInfo::VT_ADDRESS, Address);
  }
  void add_Port(int32_t Port) {
    fbb_.AddElement<int32_t>(OServerInfo::VT_PORT, Port, 0);
  }
  void add_HasCharacter(bool HasCharacter) {
    fbb_.AddElement<uint8_t>(OServerInfo::VT_HASCHARACTER, static_cast<uint8_t>(HasCharacter), 0);
  }
  void add_State(int32_t State) {
    fbb_.AddElement<int32_t>(OServerInfo::VT_STATE, State, 0);
  }
  explicit OServerInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OServerInfoBuilder &operator=(const OServerInfoBuilder &);
  flatbuffers::Offset<OServerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OServerInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<OServerInfo> CreateOServerInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ServerID = 0,
    int32_t ServerStatus = 0,
    flatbuffers::Offset<flatbuffers::String> Address = 0,
    int32_t Port = 0,
    bool HasCharacter = false,
    int32_t State = 0) {
  OServerInfoBuilder builder_(_fbb);
  builder_.add_State(State);
  builder_.add_Port(Port);
  builder_.add_Address(Address);
  builder_.add_ServerStatus(ServerStatus);
  builder_.add_ServerID(ServerID);
  builder_.add_HasCharacter(HasCharacter);
  return builder_.Finish();
}

inline flatbuffers::Offset<OServerInfo> CreateOServerInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ServerID = 0,
    int32_t ServerStatus = 0,
    const char *Address = nullptr,
    int32_t Port = 0,
    bool HasCharacter = false,
    int32_t State = 0) {
  auto Address__ = Address ? _fbb.CreateString(Address) : 0;
  return CreateOServerInfo(
      _fbb,
      ServerID,
      ServerStatus,
      Address__,
      Port,
      HasCharacter,
      State);
}

flatbuffers::Offset<OServerInfo> CreateOServerInfo(flatbuffers::FlatBufferBuilder &_fbb, const OServerInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HostConnectT : public flatbuffers::NativeTable {
  typedef HostConnect TableType;
  std::string peerip;
  int32_t peerport;
  int32_t servertype;
  int32_t serverid;
  EPacketProtocol messageid;
  HostConnectT()
      : peerport(0),
        servertype(0),
        serverid(0),
        messageid(Host_Connect) {
  }
};

struct HostConnect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostConnectT NativeTableType;
  typedef HostConnectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEERIP = 4,
    VT_PEERPORT = 6,
    VT_SERVERTYPE = 8,
    VT_SERVERID = 10,
    VT_MESSAGEID = 12
  };
  const flatbuffers::String *peerip() const {
    return GetPointer<const flatbuffers::String *>(VT_PEERIP);
  }
  int32_t peerport() const {
    return GetField<int32_t>(VT_PEERPORT, 0);
  }
  int32_t servertype() const {
    return GetField<int32_t>(VT_SERVERTYPE, 0);
  }
  int32_t serverid() const {
    return GetField<int32_t>(VT_SERVERID, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PEERIP) &&
           verifier.VerifyString(peerip()) &&
           VerifyField<int32_t>(verifier, VT_PEERPORT) &&
           VerifyField<int32_t>(verifier, VT_SERVERTYPE) &&
           VerifyField<int32_t>(verifier, VT_SERVERID) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  HostConnectT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostConnectT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostConnect> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HostConnectBuilder {
  typedef HostConnect Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peerip(flatbuffers::Offset<flatbuffers::String> peerip) {
    fbb_.AddOffset(HostConnect::VT_PEERIP, peerip);
  }
  void add_peerport(int32_t peerport) {
    fbb_.AddElement<int32_t>(HostConnect::VT_PEERPORT, peerport, 0);
  }
  void add_servertype(int32_t servertype) {
    fbb_.AddElement<int32_t>(HostConnect::VT_SERVERTYPE, servertype, 0);
  }
  void add_serverid(int32_t serverid) {
    fbb_.AddElement<int32_t>(HostConnect::VT_SERVERID, serverid, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(HostConnect::VT_MESSAGEID, static_cast<int32_t>(messageid), 1);
  }
  explicit HostConnectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HostConnectBuilder &operator=(const HostConnectBuilder &);
  flatbuffers::Offset<HostConnect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostConnect>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostConnect> CreateHostConnect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> peerip = 0,
    int32_t peerport = 0,
    int32_t servertype = 0,
    int32_t serverid = 0,
    EPacketProtocol messageid = Host_Connect) {
  HostConnectBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_serverid(serverid);
  builder_.add_servertype(servertype);
  builder_.add_peerport(peerport);
  builder_.add_peerip(peerip);
  return builder_.Finish();
}

inline flatbuffers::Offset<HostConnect> CreateHostConnectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *peerip = nullptr,
    int32_t peerport = 0,
    int32_t servertype = 0,
    int32_t serverid = 0,
    EPacketProtocol messageid = Host_Connect) {
  auto peerip__ = peerip ? _fbb.CreateString(peerip) : 0;
  return CreateHostConnect(
      _fbb,
      peerip__,
      peerport,
      servertype,
      serverid,
      messageid);
}

flatbuffers::Offset<HostConnect> CreateHostConnect(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HostCloseT : public flatbuffers::NativeTable {
  typedef HostClose TableType;
  EPacketProtocol messageid;
  HostCloseT()
      : messageid(Host_Close) {
  }
};

struct HostClose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostCloseT NativeTableType;
  typedef HostCloseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGEID = 4
  };
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 2));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  HostCloseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostCloseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostClose> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostCloseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HostCloseBuilder {
  typedef HostClose Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(HostClose::VT_MESSAGEID, static_cast<int32_t>(messageid), 2);
  }
  explicit HostCloseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HostCloseBuilder &operator=(const HostCloseBuilder &);
  flatbuffers::Offset<HostClose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostClose>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostClose> CreateHostClose(
    flatbuffers::FlatBufferBuilder &_fbb,
    EPacketProtocol messageid = Host_Close) {
  HostCloseBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  return builder_.Finish();
}

flatbuffers::Offset<HostClose> CreateHostClose(flatbuffers::FlatBufferBuilder &_fbb, const HostCloseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HostConnectFailedT : public flatbuffers::NativeTable {
  typedef HostConnectFailed TableType;
  EPacketProtocol messageid;
  HostConnectFailedT()
      : messageid(Host_ConnectFailed) {
  }
};

struct HostConnectFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostConnectFailedT NativeTableType;
  typedef HostConnectFailedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGEID = 4
  };
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 3));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  HostConnectFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostConnectFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostConnectFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HostConnectFailedBuilder {
  typedef HostConnectFailed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(HostConnectFailed::VT_MESSAGEID, static_cast<int32_t>(messageid), 3);
  }
  explicit HostConnectFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HostConnectFailedBuilder &operator=(const HostConnectFailedBuilder &);
  flatbuffers::Offset<HostConnectFailed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostConnectFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostConnectFailed> CreateHostConnectFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    EPacketProtocol messageid = Host_ConnectFailed) {
  HostConnectFailedBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  return builder_.Finish();
}

flatbuffers::Offset<HostConnectFailed> CreateHostConnectFailed(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HostHelloT : public flatbuffers::NativeTable {
  typedef HostHello TableType;
  int32_t servertype;
  int32_t serverid;
  std::string name;
  int32_t buildtype;
  EPacketProtocol messageid;
  HostHelloT()
      : servertype(0),
        serverid(0),
        buildtype(0),
        messageid(Host_Hello) {
  }
};

struct HostHello FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostHelloT NativeTableType;
  typedef HostHelloBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVERTYPE = 4,
    VT_SERVERID = 6,
    VT_NAME = 8,
    VT_BUILDTYPE = 10,
    VT_MESSAGEID = 12
  };
  int32_t servertype() const {
    return GetField<int32_t>(VT_SERVERTYPE, 0);
  }
  int32_t serverid() const {
    return GetField<int32_t>(VT_SERVERID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t buildtype() const {
    return GetField<int32_t>(VT_BUILDTYPE, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 12));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SERVERTYPE) &&
           VerifyField<int32_t>(verifier, VT_SERVERID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_BUILDTYPE) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  HostHelloT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostHelloT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostHello> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostHelloT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HostHelloBuilder {
  typedef HostHello Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_servertype(int32_t servertype) {
    fbb_.AddElement<int32_t>(HostHello::VT_SERVERTYPE, servertype, 0);
  }
  void add_serverid(int32_t serverid) {
    fbb_.AddElement<int32_t>(HostHello::VT_SERVERID, serverid, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(HostHello::VT_NAME, name);
  }
  void add_buildtype(int32_t buildtype) {
    fbb_.AddElement<int32_t>(HostHello::VT_BUILDTYPE, buildtype, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(HostHello::VT_MESSAGEID, static_cast<int32_t>(messageid), 12);
  }
  explicit HostHelloBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HostHelloBuilder &operator=(const HostHelloBuilder &);
  flatbuffers::Offset<HostHello> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostHello>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostHello> CreateHostHello(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t servertype = 0,
    int32_t serverid = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t buildtype = 0,
    EPacketProtocol messageid = Host_Hello) {
  HostHelloBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_buildtype(buildtype);
  builder_.add_name(name);
  builder_.add_serverid(serverid);
  builder_.add_servertype(servertype);
  return builder_.Finish();
}

inline flatbuffers::Offset<HostHello> CreateHostHelloDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t servertype = 0,
    int32_t serverid = 0,
    const char *name = nullptr,
    int32_t buildtype = 0,
    EPacketProtocol messageid = Host_Hello) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateHostHello(
      _fbb,
      servertype,
      serverid,
      name__,
      buildtype,
      messageid);
}

flatbuffers::Offset<HostHello> CreateHostHello(flatbuffers::FlatBufferBuilder &_fbb, const HostHelloT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CLAuthReqT : public flatbuffers::NativeTable {
  typedef CLAuthReq TableType;
  int32_t ClientType;
  int32_t AppVer;
  std::string UniqueKey;
  int32_t StoreType;
  EPacketProtocol messageid;
  CLAuthReqT()
      : ClientType(0),
        AppVer(0),
        StoreType(0),
        messageid(CL_AuthReq) {
  }
};

struct CLAuthReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CLAuthReqT NativeTableType;
  typedef CLAuthReqBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLIENTTYPE = 4,
    VT_APPVER = 6,
    VT_UNIQUEKEY = 8,
    VT_STORETYPE = 10,
    VT_MESSAGEID = 12
  };
  int32_t ClientType() const {
    return GetField<int32_t>(VT_CLIENTTYPE, 0);
  }
  int32_t AppVer() const {
    return GetField<int32_t>(VT_APPVER, 0);
  }
  const flatbuffers::String *UniqueKey() const {
    return GetPointer<const flatbuffers::String *>(VT_UNIQUEKEY);
  }
  int32_t StoreType() const {
    return GetField<int32_t>(VT_STORETYPE, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 10001));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CLIENTTYPE) &&
           VerifyField<int32_t>(verifier, VT_APPVER) &&
           VerifyOffset(verifier, VT_UNIQUEKEY) &&
           verifier.VerifyString(UniqueKey()) &&
           VerifyField<int32_t>(verifier, VT_STORETYPE) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  CLAuthReqT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CLAuthReqT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CLAuthReq> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CLAuthReqT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CLAuthReqBuilder {
  typedef CLAuthReq Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ClientType(int32_t ClientType) {
    fbb_.AddElement<int32_t>(CLAuthReq::VT_CLIENTTYPE, ClientType, 0);
  }
  void add_AppVer(int32_t AppVer) {
    fbb_.AddElement<int32_t>(CLAuthReq::VT_APPVER, AppVer, 0);
  }
  void add_UniqueKey(flatbuffers::Offset<flatbuffers::String> UniqueKey) {
    fbb_.AddOffset(CLAuthReq::VT_UNIQUEKEY, UniqueKey);
  }
  void add_StoreType(int32_t StoreType) {
    fbb_.AddElement<int32_t>(CLAuthReq::VT_STORETYPE, StoreType, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(CLAuthReq::VT_MESSAGEID, static_cast<int32_t>(messageid), 10001);
  }
  explicit CLAuthReqBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLAuthReqBuilder &operator=(const CLAuthReqBuilder &);
  flatbuffers::Offset<CLAuthReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CLAuthReq>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLAuthReq> CreateCLAuthReq(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ClientType = 0,
    int32_t AppVer = 0,
    flatbuffers::Offset<flatbuffers::String> UniqueKey = 0,
    int32_t StoreType = 0,
    EPacketProtocol messageid = CL_AuthReq) {
  CLAuthReqBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_StoreType(StoreType);
  builder_.add_UniqueKey(UniqueKey);
  builder_.add_AppVer(AppVer);
  builder_.add_ClientType(ClientType);
  return builder_.Finish();
}

inline flatbuffers::Offset<CLAuthReq> CreateCLAuthReqDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ClientType = 0,
    int32_t AppVer = 0,
    const char *UniqueKey = nullptr,
    int32_t StoreType = 0,
    EPacketProtocol messageid = CL_AuthReq) {
  auto UniqueKey__ = UniqueKey ? _fbb.CreateString(UniqueKey) : 0;
  return CreateCLAuthReq(
      _fbb,
      ClientType,
      AppVer,
      UniqueKey__,
      StoreType,
      messageid);
}

flatbuffers::Offset<CLAuthReq> CreateCLAuthReq(flatbuffers::FlatBufferBuilder &_fbb, const CLAuthReqT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LCAuthResT : public flatbuffers::NativeTable {
  typedef LCAuthRes TableType;
  int32_t AccountSeq;
  std::vector<std::unique_ptr<OServerInfoT>> ServerList;
  int32_t LastConnectServerID;
  int64_t ServerTick;
  int32_t TimeZone;
  EPacketProtocol messageid;
  LCAuthResT()
      : AccountSeq(0),
        LastConnectServerID(0),
        ServerTick(0),
        TimeZone(0),
        messageid(LC_AuthRes) {
  }
};

struct LCAuthRes FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LCAuthResT NativeTableType;
  typedef LCAuthResBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNTSEQ = 4,
    VT_SERVERLIST = 6,
    VT_LASTCONNECTSERVERID = 8,
    VT_SERVERTICK = 10,
    VT_TIMEZONE = 12,
    VT_MESSAGEID = 14
  };
  int32_t AccountSeq() const {
    return GetField<int32_t>(VT_ACCOUNTSEQ, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OServerInfo>> *ServerList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OServerInfo>> *>(VT_SERVERLIST);
  }
  int32_t LastConnectServerID() const {
    return GetField<int32_t>(VT_LASTCONNECTSERVERID, 0);
  }
  int64_t ServerTick() const {
    return GetField<int64_t>(VT_SERVERTICK, 0);
  }
  int32_t TimeZone() const {
    return GetField<int32_t>(VT_TIMEZONE, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 10004));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ACCOUNTSEQ) &&
           VerifyOffset(verifier, VT_SERVERLIST) &&
           verifier.VerifyVector(ServerList()) &&
           verifier.VerifyVectorOfTables(ServerList()) &&
           VerifyField<int32_t>(verifier, VT_LASTCONNECTSERVERID) &&
           VerifyField<int64_t>(verifier, VT_SERVERTICK) &&
           VerifyField<int32_t>(verifier, VT_TIMEZONE) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  LCAuthResT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LCAuthResT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LCAuthRes> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LCAuthResT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LCAuthResBuilder {
  typedef LCAuthRes Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_AccountSeq(int32_t AccountSeq) {
    fbb_.AddElement<int32_t>(LCAuthRes::VT_ACCOUNTSEQ, AccountSeq, 0);
  }
  void add_ServerList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OServerInfo>>> ServerList) {
    fbb_.AddOffset(LCAuthRes::VT_SERVERLIST, ServerList);
  }
  void add_LastConnectServerID(int32_t LastConnectServerID) {
    fbb_.AddElement<int32_t>(LCAuthRes::VT_LASTCONNECTSERVERID, LastConnectServerID, 0);
  }
  void add_ServerTick(int64_t ServerTick) {
    fbb_.AddElement<int64_t>(LCAuthRes::VT_SERVERTICK, ServerTick, 0);
  }
  void add_TimeZone(int32_t TimeZone) {
    fbb_.AddElement<int32_t>(LCAuthRes::VT_TIMEZONE, TimeZone, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(LCAuthRes::VT_MESSAGEID, static_cast<int32_t>(messageid), 10004);
  }
  explicit LCAuthResBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LCAuthResBuilder &operator=(const LCAuthResBuilder &);
  flatbuffers::Offset<LCAuthRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LCAuthRes>(end);
    return o;
  }
};

inline flatbuffers::Offset<LCAuthRes> CreateLCAuthRes(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t AccountSeq = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OServerInfo>>> ServerList = 0,
    int32_t LastConnectServerID = 0,
    int64_t ServerTick = 0,
    int32_t TimeZone = 0,
    EPacketProtocol messageid = LC_AuthRes) {
  LCAuthResBuilder builder_(_fbb);
  builder_.add_ServerTick(ServerTick);
  builder_.add_messageid(messageid);
  builder_.add_TimeZone(TimeZone);
  builder_.add_LastConnectServerID(LastConnectServerID);
  builder_.add_ServerList(ServerList);
  builder_.add_AccountSeq(AccountSeq);
  return builder_.Finish();
}

inline flatbuffers::Offset<LCAuthRes> CreateLCAuthResDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t AccountSeq = 0,
    const std::vector<flatbuffers::Offset<OServerInfo>> *ServerList = nullptr,
    int32_t LastConnectServerID = 0,
    int64_t ServerTick = 0,
    int32_t TimeZone = 0,
    EPacketProtocol messageid = LC_AuthRes) {
  auto ServerList__ = ServerList ? _fbb.CreateVector<flatbuffers::Offset<OServerInfo>>(*ServerList) : 0;
  return CreateLCAuthRes(
      _fbb,
      AccountSeq,
      ServerList__,
      LastConnectServerID,
      ServerTick,
      TimeZone,
      messageid);
}

flatbuffers::Offset<LCAuthRes> CreateLCAuthRes(flatbuffers::FlatBufferBuilder &_fbb, const LCAuthResT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CSEnterGameReqT : public flatbuffers::NativeTable {
  typedef CSEnterGameReq TableType;
  std::string accountid;
  std::string accountpw;
  int32_t hostid;
  EPacketProtocol messageid;
  CSEnterGameReqT()
      : hostid(0),
        messageid(CS_EnterGameReq) {
  }
};

struct CSEnterGameReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CSEnterGameReqT NativeTableType;
  typedef CSEnterGameReqBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNTID = 4,
    VT_ACCOUNTPW = 6,
    VT_HOSTID = 8,
    VT_MESSAGEID = 10
  };
  const flatbuffers::String *accountid() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNTID);
  }
  const flatbuffers::String *accountpw() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNTPW);
  }
  int32_t hostid() const {
    return GetField<int32_t>(VT_HOSTID, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 10005));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACCOUNTID) &&
           verifier.VerifyString(accountid()) &&
           VerifyOffset(verifier, VT_ACCOUNTPW) &&
           verifier.VerifyString(accountpw()) &&
           VerifyField<int32_t>(verifier, VT_HOSTID) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  CSEnterGameReqT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CSEnterGameReqT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CSEnterGameReq> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CSEnterGameReqT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CSEnterGameReqBuilder {
  typedef CSEnterGameReq Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accountid(flatbuffers::Offset<flatbuffers::String> accountid) {
    fbb_.AddOffset(CSEnterGameReq::VT_ACCOUNTID, accountid);
  }
  void add_accountpw(flatbuffers::Offset<flatbuffers::String> accountpw) {
    fbb_.AddOffset(CSEnterGameReq::VT_ACCOUNTPW, accountpw);
  }
  void add_hostid(int32_t hostid) {
    fbb_.AddElement<int32_t>(CSEnterGameReq::VT_HOSTID, hostid, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(CSEnterGameReq::VT_MESSAGEID, static_cast<int32_t>(messageid), 10005);
  }
  explicit CSEnterGameReqBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CSEnterGameReqBuilder &operator=(const CSEnterGameReqBuilder &);
  flatbuffers::Offset<CSEnterGameReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CSEnterGameReq>(end);
    return o;
  }
};

inline flatbuffers::Offset<CSEnterGameReq> CreateCSEnterGameReq(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> accountid = 0,
    flatbuffers::Offset<flatbuffers::String> accountpw = 0,
    int32_t hostid = 0,
    EPacketProtocol messageid = CS_EnterGameReq) {
  CSEnterGameReqBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_hostid(hostid);
  builder_.add_accountpw(accountpw);
  builder_.add_accountid(accountid);
  return builder_.Finish();
}

inline flatbuffers::Offset<CSEnterGameReq> CreateCSEnterGameReqDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *accountid = nullptr,
    const char *accountpw = nullptr,
    int32_t hostid = 0,
    EPacketProtocol messageid = CS_EnterGameReq) {
  auto accountid__ = accountid ? _fbb.CreateString(accountid) : 0;
  auto accountpw__ = accountpw ? _fbb.CreateString(accountpw) : 0;
  return CreateCSEnterGameReq(
      _fbb,
      accountid__,
      accountpw__,
      hostid,
      messageid);
}

flatbuffers::Offset<CSEnterGameReq> CreateCSEnterGameReq(flatbuffers::FlatBufferBuilder &_fbb, const CSEnterGameReqT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SCEnterGameAckT : public flatbuffers::NativeTable {
  typedef SCEnterGameAck TableType;
  std::string accountid;
  std::string accountpw;
  EPacketProtocol messageid;
  SCEnterGameAckT()
      : messageid(SC_EnterGameAck) {
  }
};

struct SCEnterGameAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SCEnterGameAckT NativeTableType;
  typedef SCEnterGameAckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNTID = 4,
    VT_ACCOUNTPW = 6,
    VT_MESSAGEID = 8
  };
  const flatbuffers::String *accountid() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNTID);
  }
  const flatbuffers::String *accountpw() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNTPW);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 10006));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACCOUNTID) &&
           verifier.VerifyString(accountid()) &&
           VerifyOffset(verifier, VT_ACCOUNTPW) &&
           verifier.VerifyString(accountpw()) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  SCEnterGameAckT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SCEnterGameAckT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SCEnterGameAck> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SCEnterGameAckT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SCEnterGameAckBuilder {
  typedef SCEnterGameAck Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accountid(flatbuffers::Offset<flatbuffers::String> accountid) {
    fbb_.AddOffset(SCEnterGameAck::VT_ACCOUNTID, accountid);
  }
  void add_accountpw(flatbuffers::Offset<flatbuffers::String> accountpw) {
    fbb_.AddOffset(SCEnterGameAck::VT_ACCOUNTPW, accountpw);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(SCEnterGameAck::VT_MESSAGEID, static_cast<int32_t>(messageid), 10006);
  }
  explicit SCEnterGameAckBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SCEnterGameAckBuilder &operator=(const SCEnterGameAckBuilder &);
  flatbuffers::Offset<SCEnterGameAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SCEnterGameAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<SCEnterGameAck> CreateSCEnterGameAck(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> accountid = 0,
    flatbuffers::Offset<flatbuffers::String> accountpw = 0,
    EPacketProtocol messageid = SC_EnterGameAck) {
  SCEnterGameAckBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_accountpw(accountpw);
  builder_.add_accountid(accountid);
  return builder_.Finish();
}

inline flatbuffers::Offset<SCEnterGameAck> CreateSCEnterGameAckDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *accountid = nullptr,
    const char *accountpw = nullptr,
    EPacketProtocol messageid = SC_EnterGameAck) {
  auto accountid__ = accountid ? _fbb.CreateString(accountid) : 0;
  auto accountpw__ = accountpw ? _fbb.CreateString(accountpw) : 0;
  return CreateSCEnterGameAck(
      _fbb,
      accountid__,
      accountpw__,
      messageid);
}

flatbuffers::Offset<SCEnterGameAck> CreateSCEnterGameAck(flatbuffers::FlatBufferBuilder &_fbb, const SCEnterGameAckT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SCIntegrationErrorNotificationT : public flatbuffers::NativeTable {
  typedef SCIntegrationErrorNotification TableType;
  int32_t SrcMsgID;
  int32_t Error;
  EPacketProtocol messageid;
  SCIntegrationErrorNotificationT()
      : SrcMsgID(0),
        Error(0),
        messageid(SC_IntegrationErrorNotification) {
  }
};

struct SCIntegrationErrorNotification FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SCIntegrationErrorNotificationT NativeTableType;
  typedef SCIntegrationErrorNotificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRCMSGID = 4,
    VT_ERROR = 6,
    VT_MESSAGEID = 8
  };
  int32_t SrcMsgID() const {
    return GetField<int32_t>(VT_SRCMSGID, 0);
  }
  int32_t Error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 10000));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRCMSGID) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  SCIntegrationErrorNotificationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SCIntegrationErrorNotificationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SCIntegrationErrorNotification> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SCIntegrationErrorNotificationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SCIntegrationErrorNotificationBuilder {
  typedef SCIntegrationErrorNotification Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SrcMsgID(int32_t SrcMsgID) {
    fbb_.AddElement<int32_t>(SCIntegrationErrorNotification::VT_SRCMSGID, SrcMsgID, 0);
  }
  void add_Error(int32_t Error) {
    fbb_.AddElement<int32_t>(SCIntegrationErrorNotification::VT_ERROR, Error, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(SCIntegrationErrorNotification::VT_MESSAGEID, static_cast<int32_t>(messageid), 10000);
  }
  explicit SCIntegrationErrorNotificationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SCIntegrationErrorNotificationBuilder &operator=(const SCIntegrationErrorNotificationBuilder &);
  flatbuffers::Offset<SCIntegrationErrorNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SCIntegrationErrorNotification>(end);
    return o;
  }
};

inline flatbuffers::Offset<SCIntegrationErrorNotification> CreateSCIntegrationErrorNotification(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t SrcMsgID = 0,
    int32_t Error = 0,
    EPacketProtocol messageid = SC_IntegrationErrorNotification) {
  SCIntegrationErrorNotificationBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_Error(Error);
  builder_.add_SrcMsgID(SrcMsgID);
  return builder_.Finish();
}

flatbuffers::Offset<SCIntegrationErrorNotification> CreateSCIntegrationErrorNotification(flatbuffers::FlatBufferBuilder &_fbb, const SCIntegrationErrorNotificationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline OServerInfoT *OServerInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<OServerInfoT> _o = std::unique_ptr<OServerInfoT>(new OServerInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OServerInfo::UnPackTo(OServerInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ServerID(); _o->ServerID = _e; }
  { auto _e = ServerStatus(); _o->ServerStatus = _e; }
  { auto _e = Address(); if (_e) _o->Address = _e->str(); }
  { auto _e = Port(); _o->Port = _e; }
  { auto _e = HasCharacter(); _o->HasCharacter = _e; }
  { auto _e = State(); _o->State = _e; }
}

inline flatbuffers::Offset<OServerInfo> OServerInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OServerInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOServerInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OServerInfo> CreateOServerInfo(flatbuffers::FlatBufferBuilder &_fbb, const OServerInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OServerInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ServerID = _o->ServerID;
  auto _ServerStatus = _o->ServerStatus;
  auto _Address = _o->Address.empty() ? 0 : _fbb.CreateString(_o->Address);
  auto _Port = _o->Port;
  auto _HasCharacter = _o->HasCharacter;
  auto _State = _o->State;
  return CreateOServerInfo(
      _fbb,
      _ServerID,
      _ServerStatus,
      _Address,
      _Port,
      _HasCharacter,
      _State);
}

inline HostConnectT *HostConnect::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<HostConnectT> _o = std::unique_ptr<HostConnectT>(new HostConnectT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostConnect::UnPackTo(HostConnectT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = peerip(); if (_e) _o->peerip = _e->str(); }
  { auto _e = peerport(); _o->peerport = _e; }
  { auto _e = servertype(); _o->servertype = _e; }
  { auto _e = serverid(); _o->serverid = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<HostConnect> HostConnect::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostConnect(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostConnect> CreateHostConnect(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostConnectT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _peerip = _o->peerip.empty() ? 0 : _fbb.CreateString(_o->peerip);
  auto _peerport = _o->peerport;
  auto _servertype = _o->servertype;
  auto _serverid = _o->serverid;
  auto _messageid = _o->messageid;
  return CreateHostConnect(
      _fbb,
      _peerip,
      _peerport,
      _servertype,
      _serverid,
      _messageid);
}

inline HostCloseT *HostClose::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<HostCloseT> _o = std::unique_ptr<HostCloseT>(new HostCloseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostClose::UnPackTo(HostCloseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<HostClose> HostClose::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostCloseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostClose(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostClose> CreateHostClose(flatbuffers::FlatBufferBuilder &_fbb, const HostCloseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostCloseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _messageid = _o->messageid;
  return CreateHostClose(
      _fbb,
      _messageid);
}

inline HostConnectFailedT *HostConnectFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<HostConnectFailedT> _o = std::unique_ptr<HostConnectFailedT>(new HostConnectFailedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostConnectFailed::UnPackTo(HostConnectFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<HostConnectFailed> HostConnectFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostConnectFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostConnectFailed> CreateHostConnectFailed(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostConnectFailedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _messageid = _o->messageid;
  return CreateHostConnectFailed(
      _fbb,
      _messageid);
}

inline HostHelloT *HostHello::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<HostHelloT> _o = std::unique_ptr<HostHelloT>(new HostHelloT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostHello::UnPackTo(HostHelloT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = servertype(); _o->servertype = _e; }
  { auto _e = serverid(); _o->serverid = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = buildtype(); _o->buildtype = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<HostHello> HostHello::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostHelloT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostHello(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostHello> CreateHostHello(flatbuffers::FlatBufferBuilder &_fbb, const HostHelloT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostHelloT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _servertype = _o->servertype;
  auto _serverid = _o->serverid;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _buildtype = _o->buildtype;
  auto _messageid = _o->messageid;
  return CreateHostHello(
      _fbb,
      _servertype,
      _serverid,
      _name,
      _buildtype,
      _messageid);
}

inline CLAuthReqT *CLAuthReq::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<CLAuthReqT> _o = std::unique_ptr<CLAuthReqT>(new CLAuthReqT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CLAuthReq::UnPackTo(CLAuthReqT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ClientType(); _o->ClientType = _e; }
  { auto _e = AppVer(); _o->AppVer = _e; }
  { auto _e = UniqueKey(); if (_e) _o->UniqueKey = _e->str(); }
  { auto _e = StoreType(); _o->StoreType = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<CLAuthReq> CLAuthReq::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CLAuthReqT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCLAuthReq(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CLAuthReq> CreateCLAuthReq(flatbuffers::FlatBufferBuilder &_fbb, const CLAuthReqT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CLAuthReqT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ClientType = _o->ClientType;
  auto _AppVer = _o->AppVer;
  auto _UniqueKey = _o->UniqueKey.empty() ? 0 : _fbb.CreateString(_o->UniqueKey);
  auto _StoreType = _o->StoreType;
  auto _messageid = _o->messageid;
  return CreateCLAuthReq(
      _fbb,
      _ClientType,
      _AppVer,
      _UniqueKey,
      _StoreType,
      _messageid);
}

inline LCAuthResT *LCAuthRes::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<LCAuthResT> _o = std::unique_ptr<LCAuthResT>(new LCAuthResT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LCAuthRes::UnPackTo(LCAuthResT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = AccountSeq(); _o->AccountSeq = _e; }
  { auto _e = ServerList(); if (_e) { _o->ServerList.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ServerList[_i] = std::unique_ptr<OServerInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = LastConnectServerID(); _o->LastConnectServerID = _e; }
  { auto _e = ServerTick(); _o->ServerTick = _e; }
  { auto _e = TimeZone(); _o->TimeZone = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<LCAuthRes> LCAuthRes::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LCAuthResT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLCAuthRes(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LCAuthRes> CreateLCAuthRes(flatbuffers::FlatBufferBuilder &_fbb, const LCAuthResT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LCAuthResT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _AccountSeq = _o->AccountSeq;
  auto _ServerList = _o->ServerList.size() ? _fbb.CreateVector<flatbuffers::Offset<OServerInfo>> (_o->ServerList.size(), [](size_t i, _VectorArgs *__va) { return CreateOServerInfo(*__va->__fbb, __va->__o->ServerList[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _LastConnectServerID = _o->LastConnectServerID;
  auto _ServerTick = _o->ServerTick;
  auto _TimeZone = _o->TimeZone;
  auto _messageid = _o->messageid;
  return CreateLCAuthRes(
      _fbb,
      _AccountSeq,
      _ServerList,
      _LastConnectServerID,
      _ServerTick,
      _TimeZone,
      _messageid);
}

inline CSEnterGameReqT *CSEnterGameReq::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<CSEnterGameReqT> _o = std::unique_ptr<CSEnterGameReqT>(new CSEnterGameReqT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CSEnterGameReq::UnPackTo(CSEnterGameReqT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = accountid(); if (_e) _o->accountid = _e->str(); }
  { auto _e = accountpw(); if (_e) _o->accountpw = _e->str(); }
  { auto _e = hostid(); _o->hostid = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<CSEnterGameReq> CSEnterGameReq::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CSEnterGameReqT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCSEnterGameReq(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CSEnterGameReq> CreateCSEnterGameReq(flatbuffers::FlatBufferBuilder &_fbb, const CSEnterGameReqT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CSEnterGameReqT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _accountid = _o->accountid.empty() ? 0 : _fbb.CreateString(_o->accountid);
  auto _accountpw = _o->accountpw.empty() ? 0 : _fbb.CreateString(_o->accountpw);
  auto _hostid = _o->hostid;
  auto _messageid = _o->messageid;
  return CreateCSEnterGameReq(
      _fbb,
      _accountid,
      _accountpw,
      _hostid,
      _messageid);
}

inline SCEnterGameAckT *SCEnterGameAck::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SCEnterGameAckT> _o = std::unique_ptr<SCEnterGameAckT>(new SCEnterGameAckT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SCEnterGameAck::UnPackTo(SCEnterGameAckT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = accountid(); if (_e) _o->accountid = _e->str(); }
  { auto _e = accountpw(); if (_e) _o->accountpw = _e->str(); }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<SCEnterGameAck> SCEnterGameAck::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SCEnterGameAckT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSCEnterGameAck(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SCEnterGameAck> CreateSCEnterGameAck(flatbuffers::FlatBufferBuilder &_fbb, const SCEnterGameAckT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SCEnterGameAckT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _accountid = _o->accountid.empty() ? 0 : _fbb.CreateString(_o->accountid);
  auto _accountpw = _o->accountpw.empty() ? 0 : _fbb.CreateString(_o->accountpw);
  auto _messageid = _o->messageid;
  return CreateSCEnterGameAck(
      _fbb,
      _accountid,
      _accountpw,
      _messageid);
}

inline SCIntegrationErrorNotificationT *SCIntegrationErrorNotification::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SCIntegrationErrorNotificationT> _o = std::unique_ptr<SCIntegrationErrorNotificationT>(new SCIntegrationErrorNotificationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SCIntegrationErrorNotification::UnPackTo(SCIntegrationErrorNotificationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = SrcMsgID(); _o->SrcMsgID = _e; }
  { auto _e = Error(); _o->Error = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<SCIntegrationErrorNotification> SCIntegrationErrorNotification::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SCIntegrationErrorNotificationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSCIntegrationErrorNotification(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SCIntegrationErrorNotification> CreateSCIntegrationErrorNotification(flatbuffers::FlatBufferBuilder &_fbb, const SCIntegrationErrorNotificationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SCIntegrationErrorNotificationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _SrcMsgID = _o->SrcMsgID;
  auto _Error = _o->Error;
  auto _messageid = _o->messageid;
  return CreateSCIntegrationErrorNotification(
      _fbb,
      _SrcMsgID,
      _Error,
      _messageid);
}

#endif  // FLATBUFFERS_GENERATED_PROTOCOL_H_
