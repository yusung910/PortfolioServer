// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

struct DServerInfo;
struct DServerInfoBuilder;
struct DServerInfoT;

struct DConnectServerInfo;
struct DConnectServerInfoBuilder;
struct DConnectServerInfoT;

struct DDateTime;
struct DDateTimeBuilder;
struct DDateTimeT;

struct HostConnect;
struct HostConnectBuilder;
struct HostConnectT;

struct HostClose;
struct HostCloseBuilder;
struct HostCloseT;

struct HostConnectFailed;
struct HostConnectFailedBuilder;
struct HostConnectFailedT;

struct HostHello;
struct HostHelloBuilder;
struct HostHelloT;

struct CLAuthReq;
struct CLAuthReqBuilder;
struct CLAuthReqT;

struct LCAuthRes;
struct LCAuthResBuilder;
struct LCAuthResT;

struct LCAuthErrorRes;
struct LCAuthErrorResBuilder;
struct LCAuthErrorResT;

struct LSKickDuplicateConnectUserReq;
struct LSKickDuplicateConnectUserReqBuilder;
struct LSKickDuplicateConnectUserReqT;

struct CLConnectGameServerReq;
struct CLConnectGameServerReqBuilder;
struct CLConnectGameServerReqT;

struct LCConnectGameServerRes;
struct LCConnectGameServerResBuilder;
struct LCConnectGameServerResT;

struct CSEnterGameReq;
struct CSEnterGameReqBuilder;
struct CSEnterGameReqT;

struct SCEnterGameAck;
struct SCEnterGameAckBuilder;
struct SCEnterGameAckT;

struct SCIntegrationErrorNotification;
struct SCIntegrationErrorNotificationBuilder;
struct SCIntegrationErrorNotificationT;

enum EPacketProtocol {
  //////////////////////////////////////////////////////////
  None = 0,
  Host_Connect = 1,
  Host_Close = 2,
  Host_ConnectFailed = 3,
  Host_Hello = 12,
  SC_IntegrationErrorNotification = 10000,
  //////////////////////////////////////////////////////////
  CL_AuthReq = 10001,
  LUDB_AuthReq = 10002,
  UDBL_AuthRes = 10003,
  LC_AuthRes = 10004,
  LC_AuthErrorRes = 10005,
  LS_KickDuplicateConnectUserReq = 10006,
  LUDB_ConnectServerIDClear = 10007,
  LS_Connect = 10008,
  LP_AuthLoginReq = 10009,
  PL_AuthLoginRes = 10010,
  CL_ConnectGameServerReq = 10011,
  LC_ConnectGameServerRes = 10012,
  //////////////////////////////////////////////////////////
  CS_AuthReq = 50001,
  CS_EnterGameReq = 50002,
  SC_EnterGameAck = 50003,
  PacketMax = 50004
};

inline const EPacketProtocol (&EnumValuesEPacketProtocol())[22] {
  static const EPacketProtocol values[] = {
    None,
    Host_Connect,
    Host_Close,
    Host_ConnectFailed,
    Host_Hello,
    SC_IntegrationErrorNotification,
    CL_AuthReq,
    LUDB_AuthReq,
    UDBL_AuthRes,
    LC_AuthRes,
    LC_AuthErrorRes,
    LS_KickDuplicateConnectUserReq,
    LUDB_ConnectServerIDClear,
    LS_Connect,
    LP_AuthLoginReq,
    PL_AuthLoginRes,
    CL_ConnectGameServerReq,
    LC_ConnectGameServerRes,
    CS_AuthReq,
    CS_EnterGameReq,
    SC_EnterGameAck,
    PacketMax
  };
  return values;
}

inline const char *EnumNameEPacketProtocol(EPacketProtocol e) {
  switch (e) {
    case None: return "None";
    case Host_Connect: return "Host_Connect";
    case Host_Close: return "Host_Close";
    case Host_ConnectFailed: return "Host_ConnectFailed";
    case Host_Hello: return "Host_Hello";
    case SC_IntegrationErrorNotification: return "SC_IntegrationErrorNotification";
    case CL_AuthReq: return "CL_AuthReq";
    case LUDB_AuthReq: return "LUDB_AuthReq";
    case UDBL_AuthRes: return "UDBL_AuthRes";
    case LC_AuthRes: return "LC_AuthRes";
    case LC_AuthErrorRes: return "LC_AuthErrorRes";
    case LS_KickDuplicateConnectUserReq: return "LS_KickDuplicateConnectUserReq";
    case LUDB_ConnectServerIDClear: return "LUDB_ConnectServerIDClear";
    case LS_Connect: return "LS_Connect";
    case LP_AuthLoginReq: return "LP_AuthLoginReq";
    case PL_AuthLoginRes: return "PL_AuthLoginRes";
    case CL_ConnectGameServerReq: return "CL_ConnectGameServerReq";
    case LC_ConnectGameServerRes: return "LC_ConnectGameServerRes";
    case CS_AuthReq: return "CS_AuthReq";
    case CS_EnterGameReq: return "CS_EnterGameReq";
    case SC_EnterGameAck: return "SC_EnterGameAck";
    case PacketMax: return "PacketMax";
    default: return "";
  }
}

enum EErrorMsg {
  EF_NONE = 0,
  EF_HOST_IP_IS_NOT_ALLOWED = 11,
  EF_DUPLICATE_CONNECTION_NET_ALLOWED = 12,
  EF_LOGIN_PF_ERROR = 101,
  EF_LOGIN_ACCOUNT_UNIQUE_KEY_INVALID = 102,
  EF_LOGIN_PF_GOOGLE_ERROR = 111,
  EF_LOGIN_PF_GOOGLE_ERR_PROTOCOL = 112,
  EF_LOGIN_PF_GOOGLE_ERR_SUBJECT = 113,
  EF_LOGIN_PF_GOOGLE_ERR_EXPIRE = 114,
  EF_LOGIN_PF_GOOGLE_ERR_TOKEN = 115,
  EF_LOGIN_PF_APPSTORE_ERROR = 121,
  EF_LOGIN_PF_APPSTORE_ERR_PROTOCOL = 122,
  EF_LOGIN_PF_APPSTORE_ERR_SUBJECT = 123,
  EF_LOGIN_PF_APPSTORE_ERR_EXPIRE = 124,
  EF_LOGIN_PF_APPSTORE_ERR_TOKEN = 125,
  EF_LOGIN_PF_APPSTORE_ERROR_KEYLOAD = 126,
  EF_LOGIN_PF_APPSTORE_MISSING_KEY = 127,
  EF_LOGIN_PF_APPSTORE_JWT_ERROR = 128,
  EF_LOGIN_PF_NAVER_ERROR = 131,
  EF_LOGIN_PF_FACEBOOK_ERROR = 141,
  EF_FAIL_MISSING_REQUIRED_FIELD = 10101,
  EF_KICK = 10201,
  EF_KICK_MAINTENANCE = 10202,
  EF_KICK_DUPLICATE_LOGIN = 10211,
  EF_KICK_INVALID_PLATFORM = 10212,
  EF_KICK_INVALID_APP_VERSION = 10213,
  EF_SANCTION_ACCOUNT = 11001
};

inline const EErrorMsg (&EnumValuesEErrorMsg())[27] {
  static const EErrorMsg values[] = {
    EF_NONE,
    EF_HOST_IP_IS_NOT_ALLOWED,
    EF_DUPLICATE_CONNECTION_NET_ALLOWED,
    EF_LOGIN_PF_ERROR,
    EF_LOGIN_ACCOUNT_UNIQUE_KEY_INVALID,
    EF_LOGIN_PF_GOOGLE_ERROR,
    EF_LOGIN_PF_GOOGLE_ERR_PROTOCOL,
    EF_LOGIN_PF_GOOGLE_ERR_SUBJECT,
    EF_LOGIN_PF_GOOGLE_ERR_EXPIRE,
    EF_LOGIN_PF_GOOGLE_ERR_TOKEN,
    EF_LOGIN_PF_APPSTORE_ERROR,
    EF_LOGIN_PF_APPSTORE_ERR_PROTOCOL,
    EF_LOGIN_PF_APPSTORE_ERR_SUBJECT,
    EF_LOGIN_PF_APPSTORE_ERR_EXPIRE,
    EF_LOGIN_PF_APPSTORE_ERR_TOKEN,
    EF_LOGIN_PF_APPSTORE_ERROR_KEYLOAD,
    EF_LOGIN_PF_APPSTORE_MISSING_KEY,
    EF_LOGIN_PF_APPSTORE_JWT_ERROR,
    EF_LOGIN_PF_NAVER_ERROR,
    EF_LOGIN_PF_FACEBOOK_ERROR,
    EF_FAIL_MISSING_REQUIRED_FIELD,
    EF_KICK,
    EF_KICK_MAINTENANCE,
    EF_KICK_DUPLICATE_LOGIN,
    EF_KICK_INVALID_PLATFORM,
    EF_KICK_INVALID_APP_VERSION,
    EF_SANCTION_ACCOUNT
  };
  return values;
}

inline const char *EnumNameEErrorMsg(EErrorMsg e) {
  switch (e) {
    case EF_NONE: return "EF_NONE";
    case EF_HOST_IP_IS_NOT_ALLOWED: return "EF_HOST_IP_IS_NOT_ALLOWED";
    case EF_DUPLICATE_CONNECTION_NET_ALLOWED: return "EF_DUPLICATE_CONNECTION_NET_ALLOWED";
    case EF_LOGIN_PF_ERROR: return "EF_LOGIN_PF_ERROR";
    case EF_LOGIN_ACCOUNT_UNIQUE_KEY_INVALID: return "EF_LOGIN_ACCOUNT_UNIQUE_KEY_INVALID";
    case EF_LOGIN_PF_GOOGLE_ERROR: return "EF_LOGIN_PF_GOOGLE_ERROR";
    case EF_LOGIN_PF_GOOGLE_ERR_PROTOCOL: return "EF_LOGIN_PF_GOOGLE_ERR_PROTOCOL";
    case EF_LOGIN_PF_GOOGLE_ERR_SUBJECT: return "EF_LOGIN_PF_GOOGLE_ERR_SUBJECT";
    case EF_LOGIN_PF_GOOGLE_ERR_EXPIRE: return "EF_LOGIN_PF_GOOGLE_ERR_EXPIRE";
    case EF_LOGIN_PF_GOOGLE_ERR_TOKEN: return "EF_LOGIN_PF_GOOGLE_ERR_TOKEN";
    case EF_LOGIN_PF_APPSTORE_ERROR: return "EF_LOGIN_PF_APPSTORE_ERROR";
    case EF_LOGIN_PF_APPSTORE_ERR_PROTOCOL: return "EF_LOGIN_PF_APPSTORE_ERR_PROTOCOL";
    case EF_LOGIN_PF_APPSTORE_ERR_SUBJECT: return "EF_LOGIN_PF_APPSTORE_ERR_SUBJECT";
    case EF_LOGIN_PF_APPSTORE_ERR_EXPIRE: return "EF_LOGIN_PF_APPSTORE_ERR_EXPIRE";
    case EF_LOGIN_PF_APPSTORE_ERR_TOKEN: return "EF_LOGIN_PF_APPSTORE_ERR_TOKEN";
    case EF_LOGIN_PF_APPSTORE_ERROR_KEYLOAD: return "EF_LOGIN_PF_APPSTORE_ERROR_KEYLOAD";
    case EF_LOGIN_PF_APPSTORE_MISSING_KEY: return "EF_LOGIN_PF_APPSTORE_MISSING_KEY";
    case EF_LOGIN_PF_APPSTORE_JWT_ERROR: return "EF_LOGIN_PF_APPSTORE_JWT_ERROR";
    case EF_LOGIN_PF_NAVER_ERROR: return "EF_LOGIN_PF_NAVER_ERROR";
    case EF_LOGIN_PF_FACEBOOK_ERROR: return "EF_LOGIN_PF_FACEBOOK_ERROR";
    case EF_FAIL_MISSING_REQUIRED_FIELD: return "EF_FAIL_MISSING_REQUIRED_FIELD";
    case EF_KICK: return "EF_KICK";
    case EF_KICK_MAINTENANCE: return "EF_KICK_MAINTENANCE";
    case EF_KICK_DUPLICATE_LOGIN: return "EF_KICK_DUPLICATE_LOGIN";
    case EF_KICK_INVALID_PLATFORM: return "EF_KICK_INVALID_PLATFORM";
    case EF_KICK_INVALID_APP_VERSION: return "EF_KICK_INVALID_APP_VERSION";
    case EF_SANCTION_ACCOUNT: return "EF_SANCTION_ACCOUNT";
    default: return "";
  }
}

struct DServerInfoT : public flatbuffers::NativeTable {
  typedef DServerInfo TableType;
  int32_t ServerID;
  int32_t ServerStatus;
  std::string Address;
  int32_t Port;
  bool HasCharacter;
  int32_t State;
  DServerInfoT()
      : ServerID(0),
        ServerStatus(0),
        Port(0),
        HasCharacter(false),
        State(0) {
  }
};

struct DServerInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DServerInfoT NativeTableType;
  typedef DServerInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVERID = 4,
    VT_SERVERSTATUS = 6,
    VT_ADDRESS = 8,
    VT_PORT = 10,
    VT_HASCHARACTER = 12,
    VT_STATE = 14
  };
  int32_t ServerID() const {
    return GetField<int32_t>(VT_SERVERID, 0);
  }
  int32_t ServerStatus() const {
    return GetField<int32_t>(VT_SERVERSTATUS, 0);
  }
  const flatbuffers::String *Address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  int32_t Port() const {
    return GetField<int32_t>(VT_PORT, 0);
  }
  bool HasCharacter() const {
    return GetField<uint8_t>(VT_HASCHARACTER, 0) != 0;
  }
  int32_t State() const {
    return GetField<int32_t>(VT_STATE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SERVERID) &&
           VerifyField<int32_t>(verifier, VT_SERVERSTATUS) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.VerifyString(Address()) &&
           VerifyField<int32_t>(verifier, VT_PORT) &&
           VerifyField<uint8_t>(verifier, VT_HASCHARACTER) &&
           VerifyField<int32_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
  DServerInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DServerInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DServerInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DServerInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DServerInfoBuilder {
  typedef DServerInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ServerID(int32_t ServerID) {
    fbb_.AddElement<int32_t>(DServerInfo::VT_SERVERID, ServerID, 0);
  }
  void add_ServerStatus(int32_t ServerStatus) {
    fbb_.AddElement<int32_t>(DServerInfo::VT_SERVERSTATUS, ServerStatus, 0);
  }
  void add_Address(flatbuffers::Offset<flatbuffers::String> Address) {
    fbb_.AddOffset(DServerInfo::VT_ADDRESS, Address);
  }
  void add_Port(int32_t Port) {
    fbb_.AddElement<int32_t>(DServerInfo::VT_PORT, Port, 0);
  }
  void add_HasCharacter(bool HasCharacter) {
    fbb_.AddElement<uint8_t>(DServerInfo::VT_HASCHARACTER, static_cast<uint8_t>(HasCharacter), 0);
  }
  void add_State(int32_t State) {
    fbb_.AddElement<int32_t>(DServerInfo::VT_STATE, State, 0);
  }
  explicit DServerInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DServerInfoBuilder &operator=(const DServerInfoBuilder &);
  flatbuffers::Offset<DServerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DServerInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<DServerInfo> CreateDServerInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ServerID = 0,
    int32_t ServerStatus = 0,
    flatbuffers::Offset<flatbuffers::String> Address = 0,
    int32_t Port = 0,
    bool HasCharacter = false,
    int32_t State = 0) {
  DServerInfoBuilder builder_(_fbb);
  builder_.add_State(State);
  builder_.add_Port(Port);
  builder_.add_Address(Address);
  builder_.add_ServerStatus(ServerStatus);
  builder_.add_ServerID(ServerID);
  builder_.add_HasCharacter(HasCharacter);
  return builder_.Finish();
}

inline flatbuffers::Offset<DServerInfo> CreateDServerInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ServerID = 0,
    int32_t ServerStatus = 0,
    const char *Address = nullptr,
    int32_t Port = 0,
    bool HasCharacter = false,
    int32_t State = 0) {
  auto Address__ = Address ? _fbb.CreateString(Address) : 0;
  return CreateDServerInfo(
      _fbb,
      ServerID,
      ServerStatus,
      Address__,
      Port,
      HasCharacter,
      State);
}

flatbuffers::Offset<DServerInfo> CreateDServerInfo(flatbuffers::FlatBufferBuilder &_fbb, const DServerInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DConnectServerInfoT : public flatbuffers::NativeTable {
  typedef DConnectServerInfo TableType;
  int32_t DestServerID;
  bool IsAllow;
  int32_t WaitingCount;
  int32_t OTP;
  DConnectServerInfoT()
      : DestServerID(0),
        IsAllow(false),
        WaitingCount(0),
        OTP(0) {
  }
};

struct DConnectServerInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DConnectServerInfoT NativeTableType;
  typedef DConnectServerInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DESTSERVERID = 4,
    VT_ISALLOW = 6,
    VT_WAITINGCOUNT = 8,
    VT_OTP = 10
  };
  int32_t DestServerID() const {
    return GetField<int32_t>(VT_DESTSERVERID, 0);
  }
  bool IsAllow() const {
    return GetField<uint8_t>(VT_ISALLOW, 0) != 0;
  }
  int32_t WaitingCount() const {
    return GetField<int32_t>(VT_WAITINGCOUNT, 0);
  }
  int32_t OTP() const {
    return GetField<int32_t>(VT_OTP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DESTSERVERID) &&
           VerifyField<uint8_t>(verifier, VT_ISALLOW) &&
           VerifyField<int32_t>(verifier, VT_WAITINGCOUNT) &&
           VerifyField<int32_t>(verifier, VT_OTP) &&
           verifier.EndTable();
  }
  DConnectServerInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DConnectServerInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DConnectServerInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DConnectServerInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DConnectServerInfoBuilder {
  typedef DConnectServerInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_DestServerID(int32_t DestServerID) {
    fbb_.AddElement<int32_t>(DConnectServerInfo::VT_DESTSERVERID, DestServerID, 0);
  }
  void add_IsAllow(bool IsAllow) {
    fbb_.AddElement<uint8_t>(DConnectServerInfo::VT_ISALLOW, static_cast<uint8_t>(IsAllow), 0);
  }
  void add_WaitingCount(int32_t WaitingCount) {
    fbb_.AddElement<int32_t>(DConnectServerInfo::VT_WAITINGCOUNT, WaitingCount, 0);
  }
  void add_OTP(int32_t OTP) {
    fbb_.AddElement<int32_t>(DConnectServerInfo::VT_OTP, OTP, 0);
  }
  explicit DConnectServerInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DConnectServerInfoBuilder &operator=(const DConnectServerInfoBuilder &);
  flatbuffers::Offset<DConnectServerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DConnectServerInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<DConnectServerInfo> CreateDConnectServerInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t DestServerID = 0,
    bool IsAllow = false,
    int32_t WaitingCount = 0,
    int32_t OTP = 0) {
  DConnectServerInfoBuilder builder_(_fbb);
  builder_.add_OTP(OTP);
  builder_.add_WaitingCount(WaitingCount);
  builder_.add_DestServerID(DestServerID);
  builder_.add_IsAllow(IsAllow);
  return builder_.Finish();
}

flatbuffers::Offset<DConnectServerInfo> CreateDConnectServerInfo(flatbuffers::FlatBufferBuilder &_fbb, const DConnectServerInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DDateTimeT : public flatbuffers::NativeTable {
  typedef DDateTime TableType;
  int32_t Year;
  int32_t Month;
  int32_t Day;
  int32_t Hour;
  int32_t Minute;
  int32_t Second;
  DDateTimeT()
      : Year(0),
        Month(0),
        Day(0),
        Hour(0),
        Minute(0),
        Second(0) {
  }
};

struct DDateTime FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DDateTimeT NativeTableType;
  typedef DDateTimeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_YEAR = 4,
    VT_MONTH = 6,
    VT_DAY = 8,
    VT_HOUR = 10,
    VT_MINUTE = 12,
    VT_SECOND = 14
  };
  int32_t Year() const {
    return GetField<int32_t>(VT_YEAR, 0);
  }
  int32_t Month() const {
    return GetField<int32_t>(VT_MONTH, 0);
  }
  int32_t Day() const {
    return GetField<int32_t>(VT_DAY, 0);
  }
  int32_t Hour() const {
    return GetField<int32_t>(VT_HOUR, 0);
  }
  int32_t Minute() const {
    return GetField<int32_t>(VT_MINUTE, 0);
  }
  int32_t Second() const {
    return GetField<int32_t>(VT_SECOND, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_YEAR) &&
           VerifyField<int32_t>(verifier, VT_MONTH) &&
           VerifyField<int32_t>(verifier, VT_DAY) &&
           VerifyField<int32_t>(verifier, VT_HOUR) &&
           VerifyField<int32_t>(verifier, VT_MINUTE) &&
           VerifyField<int32_t>(verifier, VT_SECOND) &&
           verifier.EndTable();
  }
  DDateTimeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DDateTimeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DDateTime> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DDateTimeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DDateTimeBuilder {
  typedef DDateTime Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Year(int32_t Year) {
    fbb_.AddElement<int32_t>(DDateTime::VT_YEAR, Year, 0);
  }
  void add_Month(int32_t Month) {
    fbb_.AddElement<int32_t>(DDateTime::VT_MONTH, Month, 0);
  }
  void add_Day(int32_t Day) {
    fbb_.AddElement<int32_t>(DDateTime::VT_DAY, Day, 0);
  }
  void add_Hour(int32_t Hour) {
    fbb_.AddElement<int32_t>(DDateTime::VT_HOUR, Hour, 0);
  }
  void add_Minute(int32_t Minute) {
    fbb_.AddElement<int32_t>(DDateTime::VT_MINUTE, Minute, 0);
  }
  void add_Second(int32_t Second) {
    fbb_.AddElement<int32_t>(DDateTime::VT_SECOND, Second, 0);
  }
  explicit DDateTimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DDateTimeBuilder &operator=(const DDateTimeBuilder &);
  flatbuffers::Offset<DDateTime> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DDateTime>(end);
    return o;
  }
};

inline flatbuffers::Offset<DDateTime> CreateDDateTime(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Year = 0,
    int32_t Month = 0,
    int32_t Day = 0,
    int32_t Hour = 0,
    int32_t Minute = 0,
    int32_t Second = 0) {
  DDateTimeBuilder builder_(_fbb);
  builder_.add_Second(Second);
  builder_.add_Minute(Minute);
  builder_.add_Hour(Hour);
  builder_.add_Day(Day);
  builder_.add_Month(Month);
  builder_.add_Year(Year);
  return builder_.Finish();
}

flatbuffers::Offset<DDateTime> CreateDDateTime(flatbuffers::FlatBufferBuilder &_fbb, const DDateTimeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HostConnectT : public flatbuffers::NativeTable {
  typedef HostConnect TableType;
  std::string peerip;
  int32_t peerport;
  int32_t servertype;
  int32_t serverid;
  EPacketProtocol messageid;
  HostConnectT()
      : peerport(0),
        servertype(0),
        serverid(0),
        messageid(Host_Connect) {
  }
};

struct HostConnect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostConnectT NativeTableType;
  typedef HostConnectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEERIP = 4,
    VT_PEERPORT = 6,
    VT_SERVERTYPE = 8,
    VT_SERVERID = 10,
    VT_MESSAGEID = 12
  };
  const flatbuffers::String *peerip() const {
    return GetPointer<const flatbuffers::String *>(VT_PEERIP);
  }
  int32_t peerport() const {
    return GetField<int32_t>(VT_PEERPORT, 0);
  }
  int32_t servertype() const {
    return GetField<int32_t>(VT_SERVERTYPE, 0);
  }
  int32_t serverid() const {
    return GetField<int32_t>(VT_SERVERID, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PEERIP) &&
           verifier.VerifyString(peerip()) &&
           VerifyField<int32_t>(verifier, VT_PEERPORT) &&
           VerifyField<int32_t>(verifier, VT_SERVERTYPE) &&
           VerifyField<int32_t>(verifier, VT_SERVERID) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  HostConnectT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostConnectT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostConnect> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HostConnectBuilder {
  typedef HostConnect Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peerip(flatbuffers::Offset<flatbuffers::String> peerip) {
    fbb_.AddOffset(HostConnect::VT_PEERIP, peerip);
  }
  void add_peerport(int32_t peerport) {
    fbb_.AddElement<int32_t>(HostConnect::VT_PEERPORT, peerport, 0);
  }
  void add_servertype(int32_t servertype) {
    fbb_.AddElement<int32_t>(HostConnect::VT_SERVERTYPE, servertype, 0);
  }
  void add_serverid(int32_t serverid) {
    fbb_.AddElement<int32_t>(HostConnect::VT_SERVERID, serverid, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(HostConnect::VT_MESSAGEID, static_cast<int32_t>(messageid), 1);
  }
  explicit HostConnectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HostConnectBuilder &operator=(const HostConnectBuilder &);
  flatbuffers::Offset<HostConnect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostConnect>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostConnect> CreateHostConnect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> peerip = 0,
    int32_t peerport = 0,
    int32_t servertype = 0,
    int32_t serverid = 0,
    EPacketProtocol messageid = Host_Connect) {
  HostConnectBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_serverid(serverid);
  builder_.add_servertype(servertype);
  builder_.add_peerport(peerport);
  builder_.add_peerip(peerip);
  return builder_.Finish();
}

inline flatbuffers::Offset<HostConnect> CreateHostConnectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *peerip = nullptr,
    int32_t peerport = 0,
    int32_t servertype = 0,
    int32_t serverid = 0,
    EPacketProtocol messageid = Host_Connect) {
  auto peerip__ = peerip ? _fbb.CreateString(peerip) : 0;
  return CreateHostConnect(
      _fbb,
      peerip__,
      peerport,
      servertype,
      serverid,
      messageid);
}

flatbuffers::Offset<HostConnect> CreateHostConnect(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HostCloseT : public flatbuffers::NativeTable {
  typedef HostClose TableType;
  EPacketProtocol messageid;
  HostCloseT()
      : messageid(Host_Close) {
  }
};

struct HostClose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostCloseT NativeTableType;
  typedef HostCloseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGEID = 4
  };
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 2));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  HostCloseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostCloseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostClose> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostCloseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HostCloseBuilder {
  typedef HostClose Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(HostClose::VT_MESSAGEID, static_cast<int32_t>(messageid), 2);
  }
  explicit HostCloseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HostCloseBuilder &operator=(const HostCloseBuilder &);
  flatbuffers::Offset<HostClose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostClose>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostClose> CreateHostClose(
    flatbuffers::FlatBufferBuilder &_fbb,
    EPacketProtocol messageid = Host_Close) {
  HostCloseBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  return builder_.Finish();
}

flatbuffers::Offset<HostClose> CreateHostClose(flatbuffers::FlatBufferBuilder &_fbb, const HostCloseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HostConnectFailedT : public flatbuffers::NativeTable {
  typedef HostConnectFailed TableType;
  EPacketProtocol messageid;
  HostConnectFailedT()
      : messageid(Host_ConnectFailed) {
  }
};

struct HostConnectFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostConnectFailedT NativeTableType;
  typedef HostConnectFailedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGEID = 4
  };
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 3));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  HostConnectFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostConnectFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostConnectFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HostConnectFailedBuilder {
  typedef HostConnectFailed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(HostConnectFailed::VT_MESSAGEID, static_cast<int32_t>(messageid), 3);
  }
  explicit HostConnectFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HostConnectFailedBuilder &operator=(const HostConnectFailedBuilder &);
  flatbuffers::Offset<HostConnectFailed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostConnectFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostConnectFailed> CreateHostConnectFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    EPacketProtocol messageid = Host_ConnectFailed) {
  HostConnectFailedBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  return builder_.Finish();
}

flatbuffers::Offset<HostConnectFailed> CreateHostConnectFailed(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HostHelloT : public flatbuffers::NativeTable {
  typedef HostHello TableType;
  int32_t servertype;
  int32_t serverid;
  std::string name;
  int32_t buildtype;
  EPacketProtocol messageid;
  HostHelloT()
      : servertype(0),
        serverid(0),
        buildtype(0),
        messageid(Host_Hello) {
  }
};

struct HostHello FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostHelloT NativeTableType;
  typedef HostHelloBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVERTYPE = 4,
    VT_SERVERID = 6,
    VT_NAME = 8,
    VT_BUILDTYPE = 10,
    VT_MESSAGEID = 12
  };
  int32_t servertype() const {
    return GetField<int32_t>(VT_SERVERTYPE, 0);
  }
  int32_t serverid() const {
    return GetField<int32_t>(VT_SERVERID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t buildtype() const {
    return GetField<int32_t>(VT_BUILDTYPE, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 12));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SERVERTYPE) &&
           VerifyField<int32_t>(verifier, VT_SERVERID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_BUILDTYPE) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  HostHelloT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostHelloT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostHello> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostHelloT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HostHelloBuilder {
  typedef HostHello Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_servertype(int32_t servertype) {
    fbb_.AddElement<int32_t>(HostHello::VT_SERVERTYPE, servertype, 0);
  }
  void add_serverid(int32_t serverid) {
    fbb_.AddElement<int32_t>(HostHello::VT_SERVERID, serverid, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(HostHello::VT_NAME, name);
  }
  void add_buildtype(int32_t buildtype) {
    fbb_.AddElement<int32_t>(HostHello::VT_BUILDTYPE, buildtype, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(HostHello::VT_MESSAGEID, static_cast<int32_t>(messageid), 12);
  }
  explicit HostHelloBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HostHelloBuilder &operator=(const HostHelloBuilder &);
  flatbuffers::Offset<HostHello> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostHello>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostHello> CreateHostHello(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t servertype = 0,
    int32_t serverid = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t buildtype = 0,
    EPacketProtocol messageid = Host_Hello) {
  HostHelloBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_buildtype(buildtype);
  builder_.add_name(name);
  builder_.add_serverid(serverid);
  builder_.add_servertype(servertype);
  return builder_.Finish();
}

inline flatbuffers::Offset<HostHello> CreateHostHelloDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t servertype = 0,
    int32_t serverid = 0,
    const char *name = nullptr,
    int32_t buildtype = 0,
    EPacketProtocol messageid = Host_Hello) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateHostHello(
      _fbb,
      servertype,
      serverid,
      name__,
      buildtype,
      messageid);
}

flatbuffers::Offset<HostHello> CreateHostHello(flatbuffers::FlatBufferBuilder &_fbb, const HostHelloT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CLAuthReqT : public flatbuffers::NativeTable {
  typedef CLAuthReq TableType;
  std::string AccountID;
  int32_t LoginPlatformType;
  std::string PlatformToken;
  int32_t ClientType;
  int32_t AppVersion;
  EPacketProtocol messageid;
  CLAuthReqT()
      : LoginPlatformType(0),
        ClientType(0),
        AppVersion(0),
        messageid(CL_AuthReq) {
  }
};

struct CLAuthReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CLAuthReqT NativeTableType;
  typedef CLAuthReqBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNTID = 4,
    VT_LOGINPLATFORMTYPE = 6,
    VT_PLATFORMTOKEN = 8,
    VT_CLIENTTYPE = 10,
    VT_APPVERSION = 12,
    VT_MESSAGEID = 14
  };
  const flatbuffers::String *AccountID() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNTID);
  }
  int32_t LoginPlatformType() const {
    return GetField<int32_t>(VT_LOGINPLATFORMTYPE, 0);
  }
  const flatbuffers::String *PlatformToken() const {
    return GetPointer<const flatbuffers::String *>(VT_PLATFORMTOKEN);
  }
  int32_t ClientType() const {
    return GetField<int32_t>(VT_CLIENTTYPE, 0);
  }
  int32_t AppVersion() const {
    return GetField<int32_t>(VT_APPVERSION, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 10001));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACCOUNTID) &&
           verifier.VerifyString(AccountID()) &&
           VerifyField<int32_t>(verifier, VT_LOGINPLATFORMTYPE) &&
           VerifyOffset(verifier, VT_PLATFORMTOKEN) &&
           verifier.VerifyString(PlatformToken()) &&
           VerifyField<int32_t>(verifier, VT_CLIENTTYPE) &&
           VerifyField<int32_t>(verifier, VT_APPVERSION) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  CLAuthReqT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CLAuthReqT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CLAuthReq> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CLAuthReqT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CLAuthReqBuilder {
  typedef CLAuthReq Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_AccountID(flatbuffers::Offset<flatbuffers::String> AccountID) {
    fbb_.AddOffset(CLAuthReq::VT_ACCOUNTID, AccountID);
  }
  void add_LoginPlatformType(int32_t LoginPlatformType) {
    fbb_.AddElement<int32_t>(CLAuthReq::VT_LOGINPLATFORMTYPE, LoginPlatformType, 0);
  }
  void add_PlatformToken(flatbuffers::Offset<flatbuffers::String> PlatformToken) {
    fbb_.AddOffset(CLAuthReq::VT_PLATFORMTOKEN, PlatformToken);
  }
  void add_ClientType(int32_t ClientType) {
    fbb_.AddElement<int32_t>(CLAuthReq::VT_CLIENTTYPE, ClientType, 0);
  }
  void add_AppVersion(int32_t AppVersion) {
    fbb_.AddElement<int32_t>(CLAuthReq::VT_APPVERSION, AppVersion, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(CLAuthReq::VT_MESSAGEID, static_cast<int32_t>(messageid), 10001);
  }
  explicit CLAuthReqBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLAuthReqBuilder &operator=(const CLAuthReqBuilder &);
  flatbuffers::Offset<CLAuthReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CLAuthReq>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLAuthReq> CreateCLAuthReq(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> AccountID = 0,
    int32_t LoginPlatformType = 0,
    flatbuffers::Offset<flatbuffers::String> PlatformToken = 0,
    int32_t ClientType = 0,
    int32_t AppVersion = 0,
    EPacketProtocol messageid = CL_AuthReq) {
  CLAuthReqBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_AppVersion(AppVersion);
  builder_.add_ClientType(ClientType);
  builder_.add_PlatformToken(PlatformToken);
  builder_.add_LoginPlatformType(LoginPlatformType);
  builder_.add_AccountID(AccountID);
  return builder_.Finish();
}

inline flatbuffers::Offset<CLAuthReq> CreateCLAuthReqDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *AccountID = nullptr,
    int32_t LoginPlatformType = 0,
    const char *PlatformToken = nullptr,
    int32_t ClientType = 0,
    int32_t AppVersion = 0,
    EPacketProtocol messageid = CL_AuthReq) {
  auto AccountID__ = AccountID ? _fbb.CreateString(AccountID) : 0;
  auto PlatformToken__ = PlatformToken ? _fbb.CreateString(PlatformToken) : 0;
  return CreateCLAuthReq(
      _fbb,
      AccountID__,
      LoginPlatformType,
      PlatformToken__,
      ClientType,
      AppVersion,
      messageid);
}

flatbuffers::Offset<CLAuthReq> CreateCLAuthReq(flatbuffers::FlatBufferBuilder &_fbb, const CLAuthReqT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LCAuthResT : public flatbuffers::NativeTable {
  typedef LCAuthRes TableType;
  int32_t AccountSeq;
  std::vector<std::unique_ptr<DServerInfoT>> ServerList;
  int32_t LastConnectServerID;
  int64_t ServerTick;
  int32_t TimeZone;
  EPacketProtocol messageid;
  LCAuthResT()
      : AccountSeq(0),
        LastConnectServerID(0),
        ServerTick(0),
        TimeZone(0),
        messageid(LC_AuthRes) {
  }
};

struct LCAuthRes FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LCAuthResT NativeTableType;
  typedef LCAuthResBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNTSEQ = 4,
    VT_SERVERLIST = 6,
    VT_LASTCONNECTSERVERID = 8,
    VT_SERVERTICK = 10,
    VT_TIMEZONE = 12,
    VT_MESSAGEID = 14
  };
  int32_t AccountSeq() const {
    return GetField<int32_t>(VT_ACCOUNTSEQ, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DServerInfo>> *ServerList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DServerInfo>> *>(VT_SERVERLIST);
  }
  int32_t LastConnectServerID() const {
    return GetField<int32_t>(VT_LASTCONNECTSERVERID, 0);
  }
  int64_t ServerTick() const {
    return GetField<int64_t>(VT_SERVERTICK, 0);
  }
  int32_t TimeZone() const {
    return GetField<int32_t>(VT_TIMEZONE, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 10004));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ACCOUNTSEQ) &&
           VerifyOffset(verifier, VT_SERVERLIST) &&
           verifier.VerifyVector(ServerList()) &&
           verifier.VerifyVectorOfTables(ServerList()) &&
           VerifyField<int32_t>(verifier, VT_LASTCONNECTSERVERID) &&
           VerifyField<int64_t>(verifier, VT_SERVERTICK) &&
           VerifyField<int32_t>(verifier, VT_TIMEZONE) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  LCAuthResT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LCAuthResT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LCAuthRes> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LCAuthResT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LCAuthResBuilder {
  typedef LCAuthRes Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_AccountSeq(int32_t AccountSeq) {
    fbb_.AddElement<int32_t>(LCAuthRes::VT_ACCOUNTSEQ, AccountSeq, 0);
  }
  void add_ServerList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DServerInfo>>> ServerList) {
    fbb_.AddOffset(LCAuthRes::VT_SERVERLIST, ServerList);
  }
  void add_LastConnectServerID(int32_t LastConnectServerID) {
    fbb_.AddElement<int32_t>(LCAuthRes::VT_LASTCONNECTSERVERID, LastConnectServerID, 0);
  }
  void add_ServerTick(int64_t ServerTick) {
    fbb_.AddElement<int64_t>(LCAuthRes::VT_SERVERTICK, ServerTick, 0);
  }
  void add_TimeZone(int32_t TimeZone) {
    fbb_.AddElement<int32_t>(LCAuthRes::VT_TIMEZONE, TimeZone, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(LCAuthRes::VT_MESSAGEID, static_cast<int32_t>(messageid), 10004);
  }
  explicit LCAuthResBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LCAuthResBuilder &operator=(const LCAuthResBuilder &);
  flatbuffers::Offset<LCAuthRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LCAuthRes>(end);
    return o;
  }
};

inline flatbuffers::Offset<LCAuthRes> CreateLCAuthRes(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t AccountSeq = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DServerInfo>>> ServerList = 0,
    int32_t LastConnectServerID = 0,
    int64_t ServerTick = 0,
    int32_t TimeZone = 0,
    EPacketProtocol messageid = LC_AuthRes) {
  LCAuthResBuilder builder_(_fbb);
  builder_.add_ServerTick(ServerTick);
  builder_.add_messageid(messageid);
  builder_.add_TimeZone(TimeZone);
  builder_.add_LastConnectServerID(LastConnectServerID);
  builder_.add_ServerList(ServerList);
  builder_.add_AccountSeq(AccountSeq);
  return builder_.Finish();
}

inline flatbuffers::Offset<LCAuthRes> CreateLCAuthResDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t AccountSeq = 0,
    const std::vector<flatbuffers::Offset<DServerInfo>> *ServerList = nullptr,
    int32_t LastConnectServerID = 0,
    int64_t ServerTick = 0,
    int32_t TimeZone = 0,
    EPacketProtocol messageid = LC_AuthRes) {
  auto ServerList__ = ServerList ? _fbb.CreateVector<flatbuffers::Offset<DServerInfo>>(*ServerList) : 0;
  return CreateLCAuthRes(
      _fbb,
      AccountSeq,
      ServerList__,
      LastConnectServerID,
      ServerTick,
      TimeZone,
      messageid);
}

flatbuffers::Offset<LCAuthRes> CreateLCAuthRes(flatbuffers::FlatBufferBuilder &_fbb, const LCAuthResT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LCAuthErrorResT : public flatbuffers::NativeTable {
  typedef LCAuthErrorRes TableType;
  int32_t ErrorCode;
  int32_t Value;
  EPacketProtocol messageid;
  LCAuthErrorResT()
      : ErrorCode(0),
        Value(0),
        messageid(LC_AuthErrorRes) {
  }
};

struct LCAuthErrorRes FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LCAuthErrorResT NativeTableType;
  typedef LCAuthErrorResBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERRORCODE = 4,
    VT_VALUE = 6,
    VT_MESSAGEID = 8
  };
  int32_t ErrorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int32_t Value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 10005));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  LCAuthErrorResT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LCAuthErrorResT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LCAuthErrorRes> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LCAuthErrorResT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LCAuthErrorResBuilder {
  typedef LCAuthErrorRes Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ErrorCode(int32_t ErrorCode) {
    fbb_.AddElement<int32_t>(LCAuthErrorRes::VT_ERRORCODE, ErrorCode, 0);
  }
  void add_Value(int32_t Value) {
    fbb_.AddElement<int32_t>(LCAuthErrorRes::VT_VALUE, Value, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(LCAuthErrorRes::VT_MESSAGEID, static_cast<int32_t>(messageid), 10005);
  }
  explicit LCAuthErrorResBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LCAuthErrorResBuilder &operator=(const LCAuthErrorResBuilder &);
  flatbuffers::Offset<LCAuthErrorRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LCAuthErrorRes>(end);
    return o;
  }
};

inline flatbuffers::Offset<LCAuthErrorRes> CreateLCAuthErrorRes(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ErrorCode = 0,
    int32_t Value = 0,
    EPacketProtocol messageid = LC_AuthErrorRes) {
  LCAuthErrorResBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_Value(Value);
  builder_.add_ErrorCode(ErrorCode);
  return builder_.Finish();
}

flatbuffers::Offset<LCAuthErrorRes> CreateLCAuthErrorRes(flatbuffers::FlatBufferBuilder &_fbb, const LCAuthErrorResT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LSKickDuplicateConnectUserReqT : public flatbuffers::NativeTable {
  typedef LSKickDuplicateConnectUserReq TableType;
  int32_t AccountSeq;
  int32_t ErrorCode;
  int32_t ExistPilgrimServerID;
  EPacketProtocol messageid;
  LSKickDuplicateConnectUserReqT()
      : AccountSeq(0),
        ErrorCode(0),
        ExistPilgrimServerID(0),
        messageid(LS_KickDuplicateConnectUserReq) {
  }
};

struct LSKickDuplicateConnectUserReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LSKickDuplicateConnectUserReqT NativeTableType;
  typedef LSKickDuplicateConnectUserReqBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNTSEQ = 4,
    VT_ERRORCODE = 6,
    VT_EXISTPILGRIMSERVERID = 8,
    VT_MESSAGEID = 10
  };
  int32_t AccountSeq() const {
    return GetField<int32_t>(VT_ACCOUNTSEQ, 0);
  }
  int32_t ErrorCode() const {
    return GetField<int32_t>(VT_ERRORCODE, 0);
  }
  int32_t ExistPilgrimServerID() const {
    return GetField<int32_t>(VT_EXISTPILGRIMSERVERID, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 10006));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ACCOUNTSEQ) &&
           VerifyField<int32_t>(verifier, VT_ERRORCODE) &&
           VerifyField<int32_t>(verifier, VT_EXISTPILGRIMSERVERID) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  LSKickDuplicateConnectUserReqT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LSKickDuplicateConnectUserReqT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LSKickDuplicateConnectUserReq> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSKickDuplicateConnectUserReqT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LSKickDuplicateConnectUserReqBuilder {
  typedef LSKickDuplicateConnectUserReq Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_AccountSeq(int32_t AccountSeq) {
    fbb_.AddElement<int32_t>(LSKickDuplicateConnectUserReq::VT_ACCOUNTSEQ, AccountSeq, 0);
  }
  void add_ErrorCode(int32_t ErrorCode) {
    fbb_.AddElement<int32_t>(LSKickDuplicateConnectUserReq::VT_ERRORCODE, ErrorCode, 0);
  }
  void add_ExistPilgrimServerID(int32_t ExistPilgrimServerID) {
    fbb_.AddElement<int32_t>(LSKickDuplicateConnectUserReq::VT_EXISTPILGRIMSERVERID, ExistPilgrimServerID, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(LSKickDuplicateConnectUserReq::VT_MESSAGEID, static_cast<int32_t>(messageid), 10006);
  }
  explicit LSKickDuplicateConnectUserReqBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LSKickDuplicateConnectUserReqBuilder &operator=(const LSKickDuplicateConnectUserReqBuilder &);
  flatbuffers::Offset<LSKickDuplicateConnectUserReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSKickDuplicateConnectUserReq>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSKickDuplicateConnectUserReq> CreateLSKickDuplicateConnectUserReq(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t AccountSeq = 0,
    int32_t ErrorCode = 0,
    int32_t ExistPilgrimServerID = 0,
    EPacketProtocol messageid = LS_KickDuplicateConnectUserReq) {
  LSKickDuplicateConnectUserReqBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_ExistPilgrimServerID(ExistPilgrimServerID);
  builder_.add_ErrorCode(ErrorCode);
  builder_.add_AccountSeq(AccountSeq);
  return builder_.Finish();
}

flatbuffers::Offset<LSKickDuplicateConnectUserReq> CreateLSKickDuplicateConnectUserReq(flatbuffers::FlatBufferBuilder &_fbb, const LSKickDuplicateConnectUserReqT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CLConnectGameServerReqT : public flatbuffers::NativeTable {
  typedef CLConnectGameServerReq TableType;
  int32_t serverid;
  EPacketProtocol messageid;
  CLConnectGameServerReqT()
      : serverid(0),
        messageid(CL_ConnectGameServerReq) {
  }
};

struct CLConnectGameServerReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CLConnectGameServerReqT NativeTableType;
  typedef CLConnectGameServerReqBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVERID = 4,
    VT_MESSAGEID = 6
  };
  int32_t serverid() const {
    return GetField<int32_t>(VT_SERVERID, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 10011));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SERVERID) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  CLConnectGameServerReqT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CLConnectGameServerReqT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CLConnectGameServerReq> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CLConnectGameServerReqT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CLConnectGameServerReqBuilder {
  typedef CLConnectGameServerReq Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_serverid(int32_t serverid) {
    fbb_.AddElement<int32_t>(CLConnectGameServerReq::VT_SERVERID, serverid, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(CLConnectGameServerReq::VT_MESSAGEID, static_cast<int32_t>(messageid), 10011);
  }
  explicit CLConnectGameServerReqBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLConnectGameServerReqBuilder &operator=(const CLConnectGameServerReqBuilder &);
  flatbuffers::Offset<CLConnectGameServerReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CLConnectGameServerReq>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLConnectGameServerReq> CreateCLConnectGameServerReq(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t serverid = 0,
    EPacketProtocol messageid = CL_ConnectGameServerReq) {
  CLConnectGameServerReqBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_serverid(serverid);
  return builder_.Finish();
}

flatbuffers::Offset<CLConnectGameServerReq> CreateCLConnectGameServerReq(flatbuffers::FlatBufferBuilder &_fbb, const CLConnectGameServerReqT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LCConnectGameServerResT : public flatbuffers::NativeTable {
  typedef LCConnectGameServerRes TableType;
  std::unique_ptr<DConnectServerInfoT> ServerInfo;
  std::unique_ptr<DConnectServerInfoT> MessengerServerInfo;
  EPacketProtocol messageid;
  LCConnectGameServerResT()
      : messageid(LC_ConnectGameServerRes) {
  }
};

struct LCConnectGameServerRes FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LCConnectGameServerResT NativeTableType;
  typedef LCConnectGameServerResBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVERINFO = 4,
    VT_MESSENGERSERVERINFO = 6,
    VT_MESSAGEID = 8
  };
  const DConnectServerInfo *ServerInfo() const {
    return GetPointer<const DConnectServerInfo *>(VT_SERVERINFO);
  }
  const DConnectServerInfo *MessengerServerInfo() const {
    return GetPointer<const DConnectServerInfo *>(VT_MESSENGERSERVERINFO);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 10012));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SERVERINFO) &&
           verifier.VerifyTable(ServerInfo()) &&
           VerifyOffset(verifier, VT_MESSENGERSERVERINFO) &&
           verifier.VerifyTable(MessengerServerInfo()) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  LCConnectGameServerResT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LCConnectGameServerResT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LCConnectGameServerRes> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LCConnectGameServerResT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LCConnectGameServerResBuilder {
  typedef LCConnectGameServerRes Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ServerInfo(flatbuffers::Offset<DConnectServerInfo> ServerInfo) {
    fbb_.AddOffset(LCConnectGameServerRes::VT_SERVERINFO, ServerInfo);
  }
  void add_MessengerServerInfo(flatbuffers::Offset<DConnectServerInfo> MessengerServerInfo) {
    fbb_.AddOffset(LCConnectGameServerRes::VT_MESSENGERSERVERINFO, MessengerServerInfo);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(LCConnectGameServerRes::VT_MESSAGEID, static_cast<int32_t>(messageid), 10012);
  }
  explicit LCConnectGameServerResBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LCConnectGameServerResBuilder &operator=(const LCConnectGameServerResBuilder &);
  flatbuffers::Offset<LCConnectGameServerRes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LCConnectGameServerRes>(end);
    return o;
  }
};

inline flatbuffers::Offset<LCConnectGameServerRes> CreateLCConnectGameServerRes(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<DConnectServerInfo> ServerInfo = 0,
    flatbuffers::Offset<DConnectServerInfo> MessengerServerInfo = 0,
    EPacketProtocol messageid = LC_ConnectGameServerRes) {
  LCConnectGameServerResBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_MessengerServerInfo(MessengerServerInfo);
  builder_.add_ServerInfo(ServerInfo);
  return builder_.Finish();
}

flatbuffers::Offset<LCConnectGameServerRes> CreateLCConnectGameServerRes(flatbuffers::FlatBufferBuilder &_fbb, const LCConnectGameServerResT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CSEnterGameReqT : public flatbuffers::NativeTable {
  typedef CSEnterGameReq TableType;
  std::string AccountID;
  std::string AccountPW;
  int32_t HostID;
  EPacketProtocol messageid;
  CSEnterGameReqT()
      : HostID(0),
        messageid(CS_EnterGameReq) {
  }
};

struct CSEnterGameReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CSEnterGameReqT NativeTableType;
  typedef CSEnterGameReqBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNTID = 4,
    VT_ACCOUNTPW = 6,
    VT_HOSTID = 8,
    VT_MESSAGEID = 10
  };
  const flatbuffers::String *AccountID() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNTID);
  }
  const flatbuffers::String *AccountPW() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNTPW);
  }
  int32_t HostID() const {
    return GetField<int32_t>(VT_HOSTID, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 50002));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACCOUNTID) &&
           verifier.VerifyString(AccountID()) &&
           VerifyOffset(verifier, VT_ACCOUNTPW) &&
           verifier.VerifyString(AccountPW()) &&
           VerifyField<int32_t>(verifier, VT_HOSTID) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  CSEnterGameReqT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CSEnterGameReqT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CSEnterGameReq> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CSEnterGameReqT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CSEnterGameReqBuilder {
  typedef CSEnterGameReq Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_AccountID(flatbuffers::Offset<flatbuffers::String> AccountID) {
    fbb_.AddOffset(CSEnterGameReq::VT_ACCOUNTID, AccountID);
  }
  void add_AccountPW(flatbuffers::Offset<flatbuffers::String> AccountPW) {
    fbb_.AddOffset(CSEnterGameReq::VT_ACCOUNTPW, AccountPW);
  }
  void add_HostID(int32_t HostID) {
    fbb_.AddElement<int32_t>(CSEnterGameReq::VT_HOSTID, HostID, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(CSEnterGameReq::VT_MESSAGEID, static_cast<int32_t>(messageid), 50002);
  }
  explicit CSEnterGameReqBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CSEnterGameReqBuilder &operator=(const CSEnterGameReqBuilder &);
  flatbuffers::Offset<CSEnterGameReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CSEnterGameReq>(end);
    return o;
  }
};

inline flatbuffers::Offset<CSEnterGameReq> CreateCSEnterGameReq(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> AccountID = 0,
    flatbuffers::Offset<flatbuffers::String> AccountPW = 0,
    int32_t HostID = 0,
    EPacketProtocol messageid = CS_EnterGameReq) {
  CSEnterGameReqBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_HostID(HostID);
  builder_.add_AccountPW(AccountPW);
  builder_.add_AccountID(AccountID);
  return builder_.Finish();
}

inline flatbuffers::Offset<CSEnterGameReq> CreateCSEnterGameReqDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *AccountID = nullptr,
    const char *AccountPW = nullptr,
    int32_t HostID = 0,
    EPacketProtocol messageid = CS_EnterGameReq) {
  auto AccountID__ = AccountID ? _fbb.CreateString(AccountID) : 0;
  auto AccountPW__ = AccountPW ? _fbb.CreateString(AccountPW) : 0;
  return CreateCSEnterGameReq(
      _fbb,
      AccountID__,
      AccountPW__,
      HostID,
      messageid);
}

flatbuffers::Offset<CSEnterGameReq> CreateCSEnterGameReq(flatbuffers::FlatBufferBuilder &_fbb, const CSEnterGameReqT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SCEnterGameAckT : public flatbuffers::NativeTable {
  typedef SCEnterGameAck TableType;
  std::string AccountID;
  std::string AccountPW;
  EPacketProtocol messageid;
  SCEnterGameAckT()
      : messageid(SC_EnterGameAck) {
  }
};

struct SCEnterGameAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SCEnterGameAckT NativeTableType;
  typedef SCEnterGameAckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNTID = 4,
    VT_ACCOUNTPW = 6,
    VT_MESSAGEID = 8
  };
  const flatbuffers::String *AccountID() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNTID);
  }
  const flatbuffers::String *AccountPW() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNTPW);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 50003));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACCOUNTID) &&
           verifier.VerifyString(AccountID()) &&
           VerifyOffset(verifier, VT_ACCOUNTPW) &&
           verifier.VerifyString(AccountPW()) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  SCEnterGameAckT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SCEnterGameAckT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SCEnterGameAck> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SCEnterGameAckT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SCEnterGameAckBuilder {
  typedef SCEnterGameAck Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_AccountID(flatbuffers::Offset<flatbuffers::String> AccountID) {
    fbb_.AddOffset(SCEnterGameAck::VT_ACCOUNTID, AccountID);
  }
  void add_AccountPW(flatbuffers::Offset<flatbuffers::String> AccountPW) {
    fbb_.AddOffset(SCEnterGameAck::VT_ACCOUNTPW, AccountPW);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(SCEnterGameAck::VT_MESSAGEID, static_cast<int32_t>(messageid), 50003);
  }
  explicit SCEnterGameAckBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SCEnterGameAckBuilder &operator=(const SCEnterGameAckBuilder &);
  flatbuffers::Offset<SCEnterGameAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SCEnterGameAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<SCEnterGameAck> CreateSCEnterGameAck(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> AccountID = 0,
    flatbuffers::Offset<flatbuffers::String> AccountPW = 0,
    EPacketProtocol messageid = SC_EnterGameAck) {
  SCEnterGameAckBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_AccountPW(AccountPW);
  builder_.add_AccountID(AccountID);
  return builder_.Finish();
}

inline flatbuffers::Offset<SCEnterGameAck> CreateSCEnterGameAckDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *AccountID = nullptr,
    const char *AccountPW = nullptr,
    EPacketProtocol messageid = SC_EnterGameAck) {
  auto AccountID__ = AccountID ? _fbb.CreateString(AccountID) : 0;
  auto AccountPW__ = AccountPW ? _fbb.CreateString(AccountPW) : 0;
  return CreateSCEnterGameAck(
      _fbb,
      AccountID__,
      AccountPW__,
      messageid);
}

flatbuffers::Offset<SCEnterGameAck> CreateSCEnterGameAck(flatbuffers::FlatBufferBuilder &_fbb, const SCEnterGameAckT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SCIntegrationErrorNotificationT : public flatbuffers::NativeTable {
  typedef SCIntegrationErrorNotification TableType;
  int32_t SrcMsgID;
  int32_t Error;
  EPacketProtocol messageid;
  SCIntegrationErrorNotificationT()
      : SrcMsgID(0),
        Error(0),
        messageid(SC_IntegrationErrorNotification) {
  }
};

struct SCIntegrationErrorNotification FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SCIntegrationErrorNotificationT NativeTableType;
  typedef SCIntegrationErrorNotificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRCMSGID = 4,
    VT_ERROR = 6,
    VT_MESSAGEID = 8
  };
  int32_t SrcMsgID() const {
    return GetField<int32_t>(VT_SRCMSGID, 0);
  }
  int32_t Error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 10000));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRCMSGID) &&
           VerifyField<int32_t>(verifier, VT_ERROR) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  SCIntegrationErrorNotificationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SCIntegrationErrorNotificationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SCIntegrationErrorNotification> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SCIntegrationErrorNotificationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SCIntegrationErrorNotificationBuilder {
  typedef SCIntegrationErrorNotification Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SrcMsgID(int32_t SrcMsgID) {
    fbb_.AddElement<int32_t>(SCIntegrationErrorNotification::VT_SRCMSGID, SrcMsgID, 0);
  }
  void add_Error(int32_t Error) {
    fbb_.AddElement<int32_t>(SCIntegrationErrorNotification::VT_ERROR, Error, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(SCIntegrationErrorNotification::VT_MESSAGEID, static_cast<int32_t>(messageid), 10000);
  }
  explicit SCIntegrationErrorNotificationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SCIntegrationErrorNotificationBuilder &operator=(const SCIntegrationErrorNotificationBuilder &);
  flatbuffers::Offset<SCIntegrationErrorNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SCIntegrationErrorNotification>(end);
    return o;
  }
};

inline flatbuffers::Offset<SCIntegrationErrorNotification> CreateSCIntegrationErrorNotification(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t SrcMsgID = 0,
    int32_t Error = 0,
    EPacketProtocol messageid = SC_IntegrationErrorNotification) {
  SCIntegrationErrorNotificationBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_Error(Error);
  builder_.add_SrcMsgID(SrcMsgID);
  return builder_.Finish();
}

flatbuffers::Offset<SCIntegrationErrorNotification> CreateSCIntegrationErrorNotification(flatbuffers::FlatBufferBuilder &_fbb, const SCIntegrationErrorNotificationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline DServerInfoT *DServerInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<DServerInfoT> _o = std::unique_ptr<DServerInfoT>(new DServerInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DServerInfo::UnPackTo(DServerInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ServerID(); _o->ServerID = _e; }
  { auto _e = ServerStatus(); _o->ServerStatus = _e; }
  { auto _e = Address(); if (_e) _o->Address = _e->str(); }
  { auto _e = Port(); _o->Port = _e; }
  { auto _e = HasCharacter(); _o->HasCharacter = _e; }
  { auto _e = State(); _o->State = _e; }
}

inline flatbuffers::Offset<DServerInfo> DServerInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DServerInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDServerInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DServerInfo> CreateDServerInfo(flatbuffers::FlatBufferBuilder &_fbb, const DServerInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DServerInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ServerID = _o->ServerID;
  auto _ServerStatus = _o->ServerStatus;
  auto _Address = _o->Address.empty() ? 0 : _fbb.CreateString(_o->Address);
  auto _Port = _o->Port;
  auto _HasCharacter = _o->HasCharacter;
  auto _State = _o->State;
  return CreateDServerInfo(
      _fbb,
      _ServerID,
      _ServerStatus,
      _Address,
      _Port,
      _HasCharacter,
      _State);
}

inline DConnectServerInfoT *DConnectServerInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<DConnectServerInfoT> _o = std::unique_ptr<DConnectServerInfoT>(new DConnectServerInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DConnectServerInfo::UnPackTo(DConnectServerInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = DestServerID(); _o->DestServerID = _e; }
  { auto _e = IsAllow(); _o->IsAllow = _e; }
  { auto _e = WaitingCount(); _o->WaitingCount = _e; }
  { auto _e = OTP(); _o->OTP = _e; }
}

inline flatbuffers::Offset<DConnectServerInfo> DConnectServerInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DConnectServerInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDConnectServerInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DConnectServerInfo> CreateDConnectServerInfo(flatbuffers::FlatBufferBuilder &_fbb, const DConnectServerInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DConnectServerInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _DestServerID = _o->DestServerID;
  auto _IsAllow = _o->IsAllow;
  auto _WaitingCount = _o->WaitingCount;
  auto _OTP = _o->OTP;
  return CreateDConnectServerInfo(
      _fbb,
      _DestServerID,
      _IsAllow,
      _WaitingCount,
      _OTP);
}

inline DDateTimeT *DDateTime::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<DDateTimeT> _o = std::unique_ptr<DDateTimeT>(new DDateTimeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DDateTime::UnPackTo(DDateTimeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Year(); _o->Year = _e; }
  { auto _e = Month(); _o->Month = _e; }
  { auto _e = Day(); _o->Day = _e; }
  { auto _e = Hour(); _o->Hour = _e; }
  { auto _e = Minute(); _o->Minute = _e; }
  { auto _e = Second(); _o->Second = _e; }
}

inline flatbuffers::Offset<DDateTime> DDateTime::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DDateTimeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDDateTime(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DDateTime> CreateDDateTime(flatbuffers::FlatBufferBuilder &_fbb, const DDateTimeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DDateTimeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Year = _o->Year;
  auto _Month = _o->Month;
  auto _Day = _o->Day;
  auto _Hour = _o->Hour;
  auto _Minute = _o->Minute;
  auto _Second = _o->Second;
  return CreateDDateTime(
      _fbb,
      _Year,
      _Month,
      _Day,
      _Hour,
      _Minute,
      _Second);
}

inline HostConnectT *HostConnect::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<HostConnectT> _o = std::unique_ptr<HostConnectT>(new HostConnectT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostConnect::UnPackTo(HostConnectT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = peerip(); if (_e) _o->peerip = _e->str(); }
  { auto _e = peerport(); _o->peerport = _e; }
  { auto _e = servertype(); _o->servertype = _e; }
  { auto _e = serverid(); _o->serverid = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<HostConnect> HostConnect::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostConnect(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostConnect> CreateHostConnect(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostConnectT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _peerip = _o->peerip.empty() ? 0 : _fbb.CreateString(_o->peerip);
  auto _peerport = _o->peerport;
  auto _servertype = _o->servertype;
  auto _serverid = _o->serverid;
  auto _messageid = _o->messageid;
  return CreateHostConnect(
      _fbb,
      _peerip,
      _peerport,
      _servertype,
      _serverid,
      _messageid);
}

inline HostCloseT *HostClose::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<HostCloseT> _o = std::unique_ptr<HostCloseT>(new HostCloseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostClose::UnPackTo(HostCloseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<HostClose> HostClose::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostCloseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostClose(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostClose> CreateHostClose(flatbuffers::FlatBufferBuilder &_fbb, const HostCloseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostCloseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _messageid = _o->messageid;
  return CreateHostClose(
      _fbb,
      _messageid);
}

inline HostConnectFailedT *HostConnectFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<HostConnectFailedT> _o = std::unique_ptr<HostConnectFailedT>(new HostConnectFailedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostConnectFailed::UnPackTo(HostConnectFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<HostConnectFailed> HostConnectFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostConnectFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostConnectFailed> CreateHostConnectFailed(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostConnectFailedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _messageid = _o->messageid;
  return CreateHostConnectFailed(
      _fbb,
      _messageid);
}

inline HostHelloT *HostHello::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<HostHelloT> _o = std::unique_ptr<HostHelloT>(new HostHelloT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostHello::UnPackTo(HostHelloT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = servertype(); _o->servertype = _e; }
  { auto _e = serverid(); _o->serverid = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = buildtype(); _o->buildtype = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<HostHello> HostHello::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostHelloT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostHello(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostHello> CreateHostHello(flatbuffers::FlatBufferBuilder &_fbb, const HostHelloT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostHelloT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _servertype = _o->servertype;
  auto _serverid = _o->serverid;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _buildtype = _o->buildtype;
  auto _messageid = _o->messageid;
  return CreateHostHello(
      _fbb,
      _servertype,
      _serverid,
      _name,
      _buildtype,
      _messageid);
}

inline CLAuthReqT *CLAuthReq::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<CLAuthReqT> _o = std::unique_ptr<CLAuthReqT>(new CLAuthReqT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CLAuthReq::UnPackTo(CLAuthReqT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = AccountID(); if (_e) _o->AccountID = _e->str(); }
  { auto _e = LoginPlatformType(); _o->LoginPlatformType = _e; }
  { auto _e = PlatformToken(); if (_e) _o->PlatformToken = _e->str(); }
  { auto _e = ClientType(); _o->ClientType = _e; }
  { auto _e = AppVersion(); _o->AppVersion = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<CLAuthReq> CLAuthReq::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CLAuthReqT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCLAuthReq(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CLAuthReq> CreateCLAuthReq(flatbuffers::FlatBufferBuilder &_fbb, const CLAuthReqT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CLAuthReqT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _AccountID = _o->AccountID.empty() ? 0 : _fbb.CreateString(_o->AccountID);
  auto _LoginPlatformType = _o->LoginPlatformType;
  auto _PlatformToken = _o->PlatformToken.empty() ? 0 : _fbb.CreateString(_o->PlatformToken);
  auto _ClientType = _o->ClientType;
  auto _AppVersion = _o->AppVersion;
  auto _messageid = _o->messageid;
  return CreateCLAuthReq(
      _fbb,
      _AccountID,
      _LoginPlatformType,
      _PlatformToken,
      _ClientType,
      _AppVersion,
      _messageid);
}

inline LCAuthResT *LCAuthRes::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<LCAuthResT> _o = std::unique_ptr<LCAuthResT>(new LCAuthResT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LCAuthRes::UnPackTo(LCAuthResT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = AccountSeq(); _o->AccountSeq = _e; }
  { auto _e = ServerList(); if (_e) { _o->ServerList.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ServerList[_i] = std::unique_ptr<DServerInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = LastConnectServerID(); _o->LastConnectServerID = _e; }
  { auto _e = ServerTick(); _o->ServerTick = _e; }
  { auto _e = TimeZone(); _o->TimeZone = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<LCAuthRes> LCAuthRes::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LCAuthResT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLCAuthRes(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LCAuthRes> CreateLCAuthRes(flatbuffers::FlatBufferBuilder &_fbb, const LCAuthResT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LCAuthResT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _AccountSeq = _o->AccountSeq;
  auto _ServerList = _o->ServerList.size() ? _fbb.CreateVector<flatbuffers::Offset<DServerInfo>> (_o->ServerList.size(), [](size_t i, _VectorArgs *__va) { return CreateDServerInfo(*__va->__fbb, __va->__o->ServerList[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _LastConnectServerID = _o->LastConnectServerID;
  auto _ServerTick = _o->ServerTick;
  auto _TimeZone = _o->TimeZone;
  auto _messageid = _o->messageid;
  return CreateLCAuthRes(
      _fbb,
      _AccountSeq,
      _ServerList,
      _LastConnectServerID,
      _ServerTick,
      _TimeZone,
      _messageid);
}

inline LCAuthErrorResT *LCAuthErrorRes::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<LCAuthErrorResT> _o = std::unique_ptr<LCAuthErrorResT>(new LCAuthErrorResT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LCAuthErrorRes::UnPackTo(LCAuthErrorResT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ErrorCode(); _o->ErrorCode = _e; }
  { auto _e = Value(); _o->Value = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<LCAuthErrorRes> LCAuthErrorRes::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LCAuthErrorResT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLCAuthErrorRes(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LCAuthErrorRes> CreateLCAuthErrorRes(flatbuffers::FlatBufferBuilder &_fbb, const LCAuthErrorResT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LCAuthErrorResT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ErrorCode = _o->ErrorCode;
  auto _Value = _o->Value;
  auto _messageid = _o->messageid;
  return CreateLCAuthErrorRes(
      _fbb,
      _ErrorCode,
      _Value,
      _messageid);
}

inline LSKickDuplicateConnectUserReqT *LSKickDuplicateConnectUserReq::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<LSKickDuplicateConnectUserReqT> _o = std::unique_ptr<LSKickDuplicateConnectUserReqT>(new LSKickDuplicateConnectUserReqT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LSKickDuplicateConnectUserReq::UnPackTo(LSKickDuplicateConnectUserReqT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = AccountSeq(); _o->AccountSeq = _e; }
  { auto _e = ErrorCode(); _o->ErrorCode = _e; }
  { auto _e = ExistPilgrimServerID(); _o->ExistPilgrimServerID = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<LSKickDuplicateConnectUserReq> LSKickDuplicateConnectUserReq::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LSKickDuplicateConnectUserReqT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLSKickDuplicateConnectUserReq(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LSKickDuplicateConnectUserReq> CreateLSKickDuplicateConnectUserReq(flatbuffers::FlatBufferBuilder &_fbb, const LSKickDuplicateConnectUserReqT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LSKickDuplicateConnectUserReqT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _AccountSeq = _o->AccountSeq;
  auto _ErrorCode = _o->ErrorCode;
  auto _ExistPilgrimServerID = _o->ExistPilgrimServerID;
  auto _messageid = _o->messageid;
  return CreateLSKickDuplicateConnectUserReq(
      _fbb,
      _AccountSeq,
      _ErrorCode,
      _ExistPilgrimServerID,
      _messageid);
}

inline CLConnectGameServerReqT *CLConnectGameServerReq::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<CLConnectGameServerReqT> _o = std::unique_ptr<CLConnectGameServerReqT>(new CLConnectGameServerReqT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CLConnectGameServerReq::UnPackTo(CLConnectGameServerReqT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = serverid(); _o->serverid = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<CLConnectGameServerReq> CLConnectGameServerReq::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CLConnectGameServerReqT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCLConnectGameServerReq(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CLConnectGameServerReq> CreateCLConnectGameServerReq(flatbuffers::FlatBufferBuilder &_fbb, const CLConnectGameServerReqT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CLConnectGameServerReqT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _serverid = _o->serverid;
  auto _messageid = _o->messageid;
  return CreateCLConnectGameServerReq(
      _fbb,
      _serverid,
      _messageid);
}

inline LCConnectGameServerResT *LCConnectGameServerRes::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<LCConnectGameServerResT> _o = std::unique_ptr<LCConnectGameServerResT>(new LCConnectGameServerResT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LCConnectGameServerRes::UnPackTo(LCConnectGameServerResT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ServerInfo(); if (_e) _o->ServerInfo = std::unique_ptr<DConnectServerInfoT>(_e->UnPack(_resolver)); }
  { auto _e = MessengerServerInfo(); if (_e) _o->MessengerServerInfo = std::unique_ptr<DConnectServerInfoT>(_e->UnPack(_resolver)); }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<LCConnectGameServerRes> LCConnectGameServerRes::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LCConnectGameServerResT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLCConnectGameServerRes(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LCConnectGameServerRes> CreateLCConnectGameServerRes(flatbuffers::FlatBufferBuilder &_fbb, const LCConnectGameServerResT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LCConnectGameServerResT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ServerInfo = _o->ServerInfo ? CreateDConnectServerInfo(_fbb, _o->ServerInfo.get(), _rehasher) : 0;
  auto _MessengerServerInfo = _o->MessengerServerInfo ? CreateDConnectServerInfo(_fbb, _o->MessengerServerInfo.get(), _rehasher) : 0;
  auto _messageid = _o->messageid;
  return CreateLCConnectGameServerRes(
      _fbb,
      _ServerInfo,
      _MessengerServerInfo,
      _messageid);
}

inline CSEnterGameReqT *CSEnterGameReq::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<CSEnterGameReqT> _o = std::unique_ptr<CSEnterGameReqT>(new CSEnterGameReqT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CSEnterGameReq::UnPackTo(CSEnterGameReqT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = AccountID(); if (_e) _o->AccountID = _e->str(); }
  { auto _e = AccountPW(); if (_e) _o->AccountPW = _e->str(); }
  { auto _e = HostID(); _o->HostID = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<CSEnterGameReq> CSEnterGameReq::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CSEnterGameReqT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCSEnterGameReq(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CSEnterGameReq> CreateCSEnterGameReq(flatbuffers::FlatBufferBuilder &_fbb, const CSEnterGameReqT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CSEnterGameReqT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _AccountID = _o->AccountID.empty() ? 0 : _fbb.CreateString(_o->AccountID);
  auto _AccountPW = _o->AccountPW.empty() ? 0 : _fbb.CreateString(_o->AccountPW);
  auto _HostID = _o->HostID;
  auto _messageid = _o->messageid;
  return CreateCSEnterGameReq(
      _fbb,
      _AccountID,
      _AccountPW,
      _HostID,
      _messageid);
}

inline SCEnterGameAckT *SCEnterGameAck::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SCEnterGameAckT> _o = std::unique_ptr<SCEnterGameAckT>(new SCEnterGameAckT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SCEnterGameAck::UnPackTo(SCEnterGameAckT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = AccountID(); if (_e) _o->AccountID = _e->str(); }
  { auto _e = AccountPW(); if (_e) _o->AccountPW = _e->str(); }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<SCEnterGameAck> SCEnterGameAck::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SCEnterGameAckT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSCEnterGameAck(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SCEnterGameAck> CreateSCEnterGameAck(flatbuffers::FlatBufferBuilder &_fbb, const SCEnterGameAckT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SCEnterGameAckT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _AccountID = _o->AccountID.empty() ? 0 : _fbb.CreateString(_o->AccountID);
  auto _AccountPW = _o->AccountPW.empty() ? 0 : _fbb.CreateString(_o->AccountPW);
  auto _messageid = _o->messageid;
  return CreateSCEnterGameAck(
      _fbb,
      _AccountID,
      _AccountPW,
      _messageid);
}

inline SCIntegrationErrorNotificationT *SCIntegrationErrorNotification::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<SCIntegrationErrorNotificationT> _o = std::unique_ptr<SCIntegrationErrorNotificationT>(new SCIntegrationErrorNotificationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SCIntegrationErrorNotification::UnPackTo(SCIntegrationErrorNotificationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = SrcMsgID(); _o->SrcMsgID = _e; }
  { auto _e = Error(); _o->Error = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<SCIntegrationErrorNotification> SCIntegrationErrorNotification::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SCIntegrationErrorNotificationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSCIntegrationErrorNotification(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SCIntegrationErrorNotification> CreateSCIntegrationErrorNotification(flatbuffers::FlatBufferBuilder &_fbb, const SCIntegrationErrorNotificationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SCIntegrationErrorNotificationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _SrcMsgID = _o->SrcMsgID;
  auto _Error = _o->Error;
  auto _messageid = _o->messageid;
  return CreateSCIntegrationErrorNotification(
      _fbb,
      _SrcMsgID,
      _Error,
      _messageid);
}

#endif  // FLATBUFFERS_GENERATED_PROTOCOL_H_
