// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

struct HostConnect;
struct HostConnectBuilder;
struct HostConnectT;

struct HostClose;
struct HostCloseBuilder;
struct HostCloseT;

struct HostConnectFailed;
struct HostConnectFailedBuilder;
struct HostConnectFailedT;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
enum EPacketProtocol {
  None = 0,
  Host_Connect = 1,
  Host_Close = 2,
  Host_ConnectFailed = 3,
  HostHi = 12,
  PacketMax = 13
};

inline const EPacketProtocol (&EnumValuesEPacketProtocol())[6] {
  static const EPacketProtocol values[] = {
    None,
    Host_Connect,
    Host_Close,
    Host_ConnectFailed,
    HostHi,
    PacketMax
  };
  return values;
}

inline const char * const *EnumNamesEPacketProtocol() {
  static const char * const names[15] = {
    "None",
    "Host_Connect",
    "Host_Close",
    "Host_ConnectFailed",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "HostHi",
    "PacketMax",
    nullptr
  };
  return names;
}

inline const char *EnumNameEPacketProtocol(EPacketProtocol e) {
  if (flatbuffers::IsOutRange(e, None, PacketMax)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEPacketProtocol()[index];
}

struct HostConnectT : public flatbuffers::NativeTable {
  typedef HostConnect TableType;
  std::string peerip;
  int32_t peerport;
  int32_t servertype;
  int32_t serverid;
  EPacketProtocol messageid;
  HostConnectT()
      : peerport(0),
        servertype(0),
        serverid(0),
        messageid(Host_Connect) {
  }
};

////////////////////////////////////////////////////////////////////////////////
struct HostConnect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostConnectT NativeTableType;
  typedef HostConnectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEERIP = 4,
    VT_PEERPORT = 6,
    VT_SERVERTYPE = 8,
    VT_SERVERID = 10,
    VT_MESSAGEID = 12
  };
  const flatbuffers::String *peerip() const {
    return GetPointer<const flatbuffers::String *>(VT_PEERIP);
  }
  int32_t peerport() const {
    return GetField<int32_t>(VT_PEERPORT, 0);
  }
  int32_t servertype() const {
    return GetField<int32_t>(VT_SERVERTYPE, 0);
  }
  int32_t serverid() const {
    return GetField<int32_t>(VT_SERVERID, 0);
  }
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PEERIP) &&
           verifier.VerifyString(peerip()) &&
           VerifyField<int32_t>(verifier, VT_PEERPORT) &&
           VerifyField<int32_t>(verifier, VT_SERVERTYPE) &&
           VerifyField<int32_t>(verifier, VT_SERVERID) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  HostConnectT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostConnectT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostConnect> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HostConnectBuilder {
  typedef HostConnect Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peerip(flatbuffers::Offset<flatbuffers::String> peerip) {
    fbb_.AddOffset(HostConnect::VT_PEERIP, peerip);
  }
  void add_peerport(int32_t peerport) {
    fbb_.AddElement<int32_t>(HostConnect::VT_PEERPORT, peerport, 0);
  }
  void add_servertype(int32_t servertype) {
    fbb_.AddElement<int32_t>(HostConnect::VT_SERVERTYPE, servertype, 0);
  }
  void add_serverid(int32_t serverid) {
    fbb_.AddElement<int32_t>(HostConnect::VT_SERVERID, serverid, 0);
  }
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(HostConnect::VT_MESSAGEID, static_cast<int32_t>(messageid), 1);
  }
  explicit HostConnectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HostConnectBuilder &operator=(const HostConnectBuilder &);
  flatbuffers::Offset<HostConnect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostConnect>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostConnect> CreateHostConnect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> peerip = 0,
    int32_t peerport = 0,
    int32_t servertype = 0,
    int32_t serverid = 0,
    EPacketProtocol messageid = Host_Connect) {
  HostConnectBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  builder_.add_serverid(serverid);
  builder_.add_servertype(servertype);
  builder_.add_peerport(peerport);
  builder_.add_peerip(peerip);
  return builder_.Finish();
}

inline flatbuffers::Offset<HostConnect> CreateHostConnectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *peerip = nullptr,
    int32_t peerport = 0,
    int32_t servertype = 0,
    int32_t serverid = 0,
    EPacketProtocol messageid = Host_Connect) {
  auto peerip__ = peerip ? _fbb.CreateString(peerip) : 0;
  return CreateHostConnect(
      _fbb,
      peerip__,
      peerport,
      servertype,
      serverid,
      messageid);
}

flatbuffers::Offset<HostConnect> CreateHostConnect(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HostCloseT : public flatbuffers::NativeTable {
  typedef HostClose TableType;
  EPacketProtocol messageid;
  HostCloseT()
      : messageid(Host_Close) {
  }
};

struct HostClose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostCloseT NativeTableType;
  typedef HostCloseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGEID = 4
  };
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 2));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  HostCloseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostCloseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostClose> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostCloseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HostCloseBuilder {
  typedef HostClose Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(HostClose::VT_MESSAGEID, static_cast<int32_t>(messageid), 2);
  }
  explicit HostCloseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HostCloseBuilder &operator=(const HostCloseBuilder &);
  flatbuffers::Offset<HostClose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostClose>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostClose> CreateHostClose(
    flatbuffers::FlatBufferBuilder &_fbb,
    EPacketProtocol messageid = Host_Close) {
  HostCloseBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  return builder_.Finish();
}

flatbuffers::Offset<HostClose> CreateHostClose(flatbuffers::FlatBufferBuilder &_fbb, const HostCloseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HostConnectFailedT : public flatbuffers::NativeTable {
  typedef HostConnectFailed TableType;
  EPacketProtocol messageid;
  HostConnectFailedT()
      : messageid(Host_ConnectFailed) {
  }
};

struct HostConnectFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostConnectFailedT NativeTableType;
  typedef HostConnectFailedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGEID = 4
  };
  EPacketProtocol messageid() const {
    return static_cast<EPacketProtocol>(GetField<int32_t>(VT_MESSAGEID, 3));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MESSAGEID) &&
           verifier.EndTable();
  }
  HostConnectFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostConnectFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostConnectFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HostConnectFailedBuilder {
  typedef HostConnectFailed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_messageid(EPacketProtocol messageid) {
    fbb_.AddElement<int32_t>(HostConnectFailed::VT_MESSAGEID, static_cast<int32_t>(messageid), 3);
  }
  explicit HostConnectFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HostConnectFailedBuilder &operator=(const HostConnectFailedBuilder &);
  flatbuffers::Offset<HostConnectFailed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostConnectFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostConnectFailed> CreateHostConnectFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    EPacketProtocol messageid = Host_ConnectFailed) {
  HostConnectFailedBuilder builder_(_fbb);
  builder_.add_messageid(messageid);
  return builder_.Finish();
}

flatbuffers::Offset<HostConnectFailed> CreateHostConnectFailed(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline HostConnectT *HostConnect::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<HostConnectT> _o = std::unique_ptr<HostConnectT>(new HostConnectT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostConnect::UnPackTo(HostConnectT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = peerip(); if (_e) _o->peerip = _e->str(); }
  { auto _e = peerport(); _o->peerport = _e; }
  { auto _e = servertype(); _o->servertype = _e; }
  { auto _e = serverid(); _o->serverid = _e; }
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<HostConnect> HostConnect::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostConnect(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostConnect> CreateHostConnect(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostConnectT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _peerip = _o->peerip.empty() ? 0 : _fbb.CreateString(_o->peerip);
  auto _peerport = _o->peerport;
  auto _servertype = _o->servertype;
  auto _serverid = _o->serverid;
  auto _messageid = _o->messageid;
  return CreateHostConnect(
      _fbb,
      _peerip,
      _peerport,
      _servertype,
      _serverid,
      _messageid);
}

inline HostCloseT *HostClose::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<HostCloseT> _o = std::unique_ptr<HostCloseT>(new HostCloseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostClose::UnPackTo(HostCloseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<HostClose> HostClose::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostCloseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostClose(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostClose> CreateHostClose(flatbuffers::FlatBufferBuilder &_fbb, const HostCloseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostCloseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _messageid = _o->messageid;
  return CreateHostClose(
      _fbb,
      _messageid);
}

inline HostConnectFailedT *HostConnectFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<HostConnectFailedT> _o = std::unique_ptr<HostConnectFailedT>(new HostConnectFailedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostConnectFailed::UnPackTo(HostConnectFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = messageid(); _o->messageid = _e; }
}

inline flatbuffers::Offset<HostConnectFailed> HostConnectFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostConnectFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostConnectFailed> CreateHostConnectFailed(flatbuffers::FlatBufferBuilder &_fbb, const HostConnectFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostConnectFailedT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _messageid = _o->messageid;
  return CreateHostConnectFailed(
      _fbb,
      _messageid);
}

#endif  // FLATBUFFERS_GENERATED_PROTOCOL_H_
